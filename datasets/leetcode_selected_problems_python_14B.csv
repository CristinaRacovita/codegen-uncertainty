title,description,difficulty,solution
Relative Ranks,"You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:
The `1st` place athlete's rank is `""Gold Medal""`.

The `2nd` place athlete's rank is `""Silver Medal""`.

The `3rd` place athlete's rank is `""Bronze Medal""`.

For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `""x""`).

Return an array `answer` of size `n` where `answer[i]` is the rank of the `ith` athlete.


Example 1:
Input: score = [5,4,3,2,1]
Output: [""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].


Example 2:
Input: score = [10,3,8,9,4]
Output: [""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].


Constraints:
`n == score.length`
`1 <= n <= 104`
`0 <= score[i] <= 106`
All the values in `score` are unique.",Easy,"def findRelativeRanks(score):
    # Step 1: Create a copy of the scores
    sorted_scores = score[:]
    
    # Step 2: Sort the scores in descending order using bubble sort
    n = len(sorted_scores)
    for i in range(n):
        for j in range(0, n-i-1):
            if sorted_scores[j] < sorted_scores[j+1]:
                sorted_scores[j], sorted_scores[j+1] = sorted_scores[j+1], sorted_scores[j]
    
    # Step 3: Assign ranks
    rank_dict = {}
    for idx, value in enumerate(sorted_scores):
        if idx == 0:
            rank_dict[value] = ""Gold Medal""
        elif idx == 1:
            rank_dict[value] = ""Silver Medal""
        elif idx == 2:
            rank_dict[value] = ""Bronze Medal""
        else:
            rank_dict[value] = str(idx + 1)
    
    # Step 4: Map ranks back to original scores
    result = []
    for s in score:
        result.append(rank_dict[s])
    
    # Step 5: Return the result
    return result

# Example usage:
print(findRelativeRanks([5, 4, 3, 2, 1]))  # Output: [""Gold Medal"", ""Silver Medal"", ""Bronze Medal"", ""4"", ""5""]
print(findRelativeRanks([10, 3, 8, 9, 4]))  # Output: [""Gold Medal"", ""5"", ""Bronze Medal"", ""Silver Medal"", ""4""]"
Truncate Sentence,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, `""Hello World""`, `""HELLO""`, and `""hello world hello world""` are all sentences.

You are given a sentence `s`​​​​​​ and an integer `k`​​​​​​. You want to truncate `s`​​​​​​ such that it contains only the first `k`​​​​​​ words. Return `s`​​​​​​ after truncating it.


Example 1:
Input: s = ""Hello how are you Contestant"", k = 4
Output: ""Hello how are you""
Explanation:
The words in s are [""Hello"", ""how"" ""are"", ""you"", ""Contestant""].

The first 4 words are [""Hello"", ""how"", ""are"", ""you""].

Hence, you should return ""Hello how are you"".


Example 2:
Input: s = ""What is the solution to this problem"", k = 4
Output: ""What is the solution""
Explanation:
The words in s are [""What"", ""is"" ""the"", ""solution"", ""to"", ""this"", ""problem""].

The first 4 words are [""What"", ""is"", ""the"", ""solution""].

Hence, you should return ""What is the solution"".


Example 3:
Input: s = ""chopper is not a tanuki"", k = 5
Output: ""chopper is not a tanuki""

Constraints:
`1 <= s.length <= 500`
`k` is in the range `[1, the number of words in s]`.

`s` consist of only lowercase and uppercase English letters and spaces.

The words in `s` are separated by a single space.

There are no leading or trailing spaces.",Easy,"def truncate_sentence(s, k):
    # Initialize variables
    truncated_words = []
    current_word = """"
    
    # Iterate through each character in the string
    for char in s:
        if char == ' ':
            # If a space is found, it means the end of a word
            if len(truncated_words) < k:
                truncated_words.append(current_word)
                current_word = """"
        else:
            # Otherwise, keep building the current word
            current_word += char
    
    # Add the last word if it hasn't been added yet
    if len(truncated_words) < k:
        truncated_words.append(current_word)
    
    # Construct the truncated sentence
    truncated_sentence = """"
    for i in range(len(truncated_words)):
        truncated_sentence += truncated_words[i]
        if i < len(truncated_words) - 1:
            truncated_sentence += ' '
    
    return truncated_sentence

# Example usage:
print(truncate_sentence(""Hello how are you Contestant"", 4))  # Output: ""Hello how are you""
print(truncate_sentence(""What is the solution to this problem"", 4))  # Output: ""What is the solution""
print(truncate_sentence(""chopper is not a tanuki"", 5))  # Output: ""chopper is not a tanuki"""
Perform String Shifts,"You are given a string `s` containing lowercase English letters, and a matrix `shift`, where `shift[i] = [direction, amount]`:
`direction` can be `0` (for left shift) or `1` (for right shift). 
`amount` is the amount by which string `s` is to be shifted.

A left shift by 1 means remove the first character of `s` and append it to the end.

Similarly, a right shift by 1 means remove the last character of `s` and add it to the beginning.

Return the final string after all operations.


Example 1:
Input: s = ""abc"", shift = [[0,1],[1,2]]
Output: ""cab""
Explanation: 
[0,1] means shift to left by 1. ""abc"" -> ""bca""
[1,2] means shift to right by 2. ""bca"" -> ""cab""

Example 2:
Input: s = ""abcdefg"", shift = [[1,1],[1,1],[0,2],[1,3]]
Output: ""efgabcd""
Explanation:  
[1,1] means shift to right by 1. ""abcdefg"" -> ""gabcdef""
[1,1] means shift to right by 1. ""gabcdef"" -> ""fgabcde""
[0,2] means shift to left by 2. ""fgabcde"" -> ""abcdefg""
[1,3] means shift to right by 3. ""abcdefg"" -> ""efgabcd""

Constraints:
`1 <= s.length <= 100`
`s` only contains lower case English letters.

`1 <= shift.length <= 100`
`shift[i].length == 2`
`0 <= shift[i][0] <= 1`
`0 <= shift[i][1] <= 100`",Easy,"def stringShift(s, shift):
    # Calculate net shift
    net_shift = 0
    for direction, amount in shift:
        if direction == 0:
            net_shift -= amount
        else:
            net_shift += amount
    
    # Normalize the net shift
    n = len(s)
    net_shift = net_shift % n
    
    # Apply the net shift
    if net_shift > 0:
        # Right shift
        return s[-net_shift:] + s[:-net_shift]
    elif net_shift < 0:
        # Left shift (convert to equivalent positive right shift)
        net_shift = -net_shift
        return s[net_shift:] + s[:net_shift]
    else:
        # No shift
        return s

# Example usage:
s1 = ""abc""
shift1 = [[0, 1], [1, 2]]
print(stringShift(s1, shift1))  # Output: ""cab""

s2 = ""abcdefg""
shift2 = [[1, 1], [1, 1], [0, 2], [1, 3]]
print(stringShift(s2, shift2))  # Output: ""efgabcd"""
Invert Binary Tree,"Given the `root` of a binary tree, invert the tree, and return its root.


Example 1:
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

Example 2:
Input: root = [2,1,3]
Output: [2,3,1]

Example 3:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree is in the range `[0, 100]`.

`-100 <= Node.val <= 100`",Easy,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    # Base case: if the current node is None, return None
    if root is None:
        return None
    
    # Recursive case: swap the left and right children
    temp = root.left
    root.left = root.right
    root.right = temp
    
    # Recursively invert the left and right subtrees
    invertTree(root.left)
    invertTree(root.right)
    
    # Return the root of the inverted tree
    return root

# Example usage:
# Constructing the tree for example 1: [4,2,7,1,3,6,9]
root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(7)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(6)
root.right.right = TreeNode(9)

# Invert the tree
inverted_root = invertTree(root)

# Function to print the tree in level order (for verification)
def printLevelOrder(root):
    if root is None:
        return
    queue = []
    queue.append(root)
    while len(queue) > 0:
        node = queue.pop(0)
        print(node.val, end="" "")
        if node.left is not None:
            queue.append(node.left)
        if node.right is not None:
            queue.append(node.right)
    print()

# Print the inverted tree
printLevelOrder(inverted_root)"
Merge Strings Alternately,"You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.


Example 1:
Input: word1 = ""abc"", word2 = ""pqr""
Output: ""apbqcr""
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r

Example 2:
Input: word1 = ""ab"", word2 = ""pqrs""
Output: ""apbqrs""
Explanation: Notice that as word2 is longer, ""rs"" is appended to the end.

word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s

Example 3:
Input: word1 = ""abcd"", word2 = ""pq""
Output: ""apbqcd""
Explanation: Notice that as word1 is longer, ""cd"" is appended to the end.

word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d

Constraints:
`1 <= word1.length, word2.length <= 100`
`word1` and `word2` consist of lowercase English letters.",Easy,"def merge_strings(word1, word2):
    # Initialize an empty list to store the merged characters
    merged = []
    
    # Get the lengths of both words
    len1 = 0
    for _ in word1:
        len1 += 1
    
    len2 = 0
    for _ in word2:
        len2 += 1
    
    # Determine the maximum length of the two words
    max_len = len1 if len1 > len2 else len2
    
    # Iterate through the range of the maximum length
    for i in range(max_len):
        # If the current index is within the bounds of word1, add the character to the merged list
        if i < len1:
            merged.append(word1[i])
        
        # If the current index is within the bounds of word2, add the character to the merged list
        if i < len2:
            merged.append(word2[i])
    
    # Convert the list of characters back to a string and return it
    result = """"
    for char in merged:
        result += char
    
    return result

# Example usage:
print(merge_strings(""abc"", ""pqr""))  # Output: ""apbqcr""
print(merge_strings(""ab"", ""pqrs""))  # Output: ""apbqrs""
print(merge_strings(""abcd"", ""pq""))  # Output: ""apbqcd"""
Delete N Nodes After M Nodes of a Linked List,"Given the `head` of a linked list and two integers `m` and `n`. Traverse the linked list and remove some nodes in the following way:
Start with the head as the current node.

Keep the first `m` nodes starting with the current node.

Remove the next `n` nodes
Keep repeating steps 2 and 3 until you reach the end of the list.

Return the head of the modified list after removing the mentioned nodes.

Follow up question: How can you solve this problem by modifying the list in-place?

Example 1:
Input: head = [1,2,3,4,5,6,7,8,9,10,11,12,13], m = 2, n = 3
Output: [1,2,6,7,11,12]
Explanation: Keep the first (m = 2) nodes starting from the head of the linked List  (1 ->2) show in black nodes.

Delete the next (n = 3) nodes (3 -> 4 -> 5) show in read nodes.

Continue with the same procedure until reaching the tail of the Linked List.

Head of linked list after removing nodes is returned.


Example 2:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 1, n = 3
Output: [1,5,9]
Explanation: Head of linked list after removing nodes is returned.


Example 3:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 3, n = 1
Output: [1,2,3,5,6,7,9,10,11]

Example 4:
Input: head = [9,3,7,7,9,10,8,2], m = 1, n = 2
Output: [9,7,8]

Constraints:
The given linked list will contain between `1` and `10^4` nodes.

The value of each node in the linked list will be in the range` [1, 10^6]`.

`1 <= m,n <= 1000`",Easy,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNodes(head, m, n):
    current = head
    previous = None
    
    while current:
        # Keep m nodes
        for _ in range(m):
            if not current:
                break
            previous = current
            current = current.next
        
        # Remove n nodes
        for _ in range(n):
            if not current:
                break
            current = current.next
        
        # Link the remaining nodes
        if previous:
            previous.next = current
    
    return head

# Example usage:
# Create the linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13
head = ListNode(1)
current = head
for i in range(2, 14):
    current.next = ListNode(i)
    current = current.next

# Call the function with m=2, n=3
new_head = deleteNodes(head, 2, 3)

# Print the modified list
current = new_head
while current:
    print(current.val, end="" "")
    current = current.next"
Reverse Linked List,"Given the `head` of a singly linked list, reverse the list, and return the reversed list.


Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:
Input: head = [1,2]
Output: [2,1]

Example 3:
Input: head = []
Output: []

Constraints:
The number of nodes in the list is the range `[0, 5000]`.

`-5000 <= Node.val <= 5000`
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",Easy,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseListIterative(head):
    prev = None
    current = head
    while current is not None:
        next_node = current.next  # Store next node
        current.next = prev       # Reverse current node's pointer
        prev = current            # Move pointers one position ahead
        current = next_node
    return prev  # New head of the reversed list"
How Many Numbers Are Smaller Than the Current Number,"Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j's` such that `j != i` and `nums[j] < nums[i]`.

Return the answer in an array.


Example 1:
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.

For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).


Example 2:
Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Example 3:
Input: nums = [7,7,7,7]
Output: [0,0,0,0]

Constraints:
`2 <= nums.length <= 500`
`0 <= nums[i] <= 100`",Easy,"def smaller_numbers_than_current(nums):
    result = []
    n = len(nums)
    
    for i in range(n):
        count = 0
        for j in range(i):
            if nums[j] < nums[i]:
                count += 1
        result.append(count)
    
    return result

# Example usage:
print(smaller_numbers_than_current([8, 1, 2, 2, 3]))  # Output: [4, 0, 1, 1, 3]
print(smaller_numbers_than_current([6, 5, 4, 8]))     # Output: [2, 1, 0, 3]
print(smaller_numbers_than_current([7, 7, 7, 7]))     # Output: [0, 0, 0, 0]"
Find All The Lonely Nodes,"In a binary tree, a lonely node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.

Given the `root` of a binary tree, return an array containing the values of all lonely nodes in the tree. Return the list in any order.


Example 1:
Input: root = [1,2,3,null,4]
Output: [4]
Explanation: Light blue node is the only lonely node.

Node 1 is the root and is not lonely.

Nodes 2 and 3 have the same parent and are not lonely.


Example 2:
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
Output: [6,2]
Explanation: Light blue nodes are lonely nodes.

Please remember that order doesn't matter, [2,6] is also an acceptable answer.


Example 3:
Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
Output: [77,55,33,66,44,22]
Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.

All other nodes are lonely.


Example 4:
Input: root = [197]
Output: []

Example 5:
Input: root = [31,null,78,null,28]
Output: [78,28]

Constraints:
The number of nodes in the `tree` is in the range `[1, 1000].`
Each node's value is between `[1, 10^6]`.",Easy,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findLonelyNodes(root):
    lonely_nodes = []
    
    def dfs(node):
        if node is None:
            return
        
        # Check if the current node has only one child
        if node.left is None and node.right is not None:
            lonely_nodes.append(node.right.val)
        elif node.left is not None and node.right is None:
            lonely_nodes.append(node.left.val)
        
        # Traverse the left and right subtrees
        dfs(node.left)
        dfs(node.right)
    
    # Start DFS from the root
    dfs(root)
    
    return lonely_nodes

# Example usage:
# Construct the tree for example 1: [1,2,3,null,4]
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.right = TreeNode(4)

print(findLonelyNodes(root))  # Output: [4]"
Maximum Ascending Subarray Sum,"Given an array of positive integers `nums`, return the maximum possible sum of an ascending subarray in `nums`.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is ascending if for all `i` where `l <= i < r`, `numsi  < numsi+1`. Note that a subarray of size `1` is ascending.


Example 1:
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.


Example 2:
Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.


Example 3:
Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.


Example 4:
Input: nums = [100,10,1]
Output: 100

Constraints:
`1 <= nums.length <= 100`
`1 <= nums[i] <= 100`",Easy,"def max_ascending_subarray_sum(nums):
    # Initialize variables
    max_sum = 0  # This will store the maximum sum of an ascending subarray
    current_sum = nums[0]  # Start with the first element as the initial current sum
    n = len(nums)  # Length of the input array

    # Iterate through the array starting from the second element
    for i in range(1, n):
        if nums[i] > nums[i - 1]:
            # If the current element is greater than the previous one, add it to the current sum
            current_sum += nums[i]
        else:
            # Otherwise, compare the current sum with the maximum sum and update if necessary
            if current_sum > max_sum:
                max_sum = current_sum
            # Reset the current sum to start a new subarray with the current element
            current_sum = nums[i]

    # After the loop, make sure to check the last subarray
    if current_sum > max_sum:
        max_sum = current_sum

    return max_sum

# Example usage:
print(max_ascending_subarray_sum([10, 20, 30, 5, 10, 50]))  # Output: 65
print(max_ascending_subarray_sum([10, 20, 30, 40, 50]))  # Output: 150
print(max_ascending_subarray_sum([12, 17, 15, 13, 10, 11, 12]))  # Output: 33
print(max_ascending_subarray_sum([100, 10, 1]))  # Output: 100"
Maximum Subarray Sum After One Operation,"You are given an integer array `nums`. You must perform exactly one operation where you can replace one element `nums[i]` with `nums[i] * nums[i]`. 
Return the maximum possible subarray sum after exactly one operation. The subarray must be non-empty.


Example 1:
Input: nums = [2,-1,-4,-3]
Output: 17
Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.


Example 2:
Input: nums = [1,-1,1,1,-1,-1,1]
Output: 4
Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.


Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`",Medium,"def max_subarray_sum_after_one_square(nums):
    n = len(nums)
    
    if n == 0:
        return 0
    
    # Initialize variables
    max_ending_here = nums[0]
    max_with_square_ending_here = nums[0] ** 2
    global_max = max(max_ending_here, max_with_square_ending_here)
    
    for i in range(1, n):
        # Update max_ending_here
        if max_ending_here > 0:
            max_ending_here += nums[i]
        else:
            max_ending_here = nums[i]
        
        # Update max_with_square_ending_here
        # Option 1: Continue the subarray without squaring
        max_with_square_continue = max_ending_here + nums[i] ** 2
        # Option 2: Start a new subarray with squaring
        max_with_square_start = nums[i] ** 2
        # Option 3: Continue the subarray with the previous square
        max_with_square_ending_here = max(max_with_square_ending_here + nums[i], max_with_square_continue, max_with_square_start)
        
        # Update the global maximum
        global_max = max(global_max, max_ending_here, max_with_square_ending_here)
    
    return global_max

# Example usage:
print(max_subarray_sum_after_one_square([2, -1, -4, -3]))  # Output: 17
print(max_subarray_sum_after_one_square([1, -1, 1, 1, -1, -1, 1]))  # Output: 4"
Walls and Gates,"You are given an `m x n` grid `rooms` initialized with these three possible values.

`-1` A wall or an obstacle.

`0` A gate.

`INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with `INF`.


Example 1:
Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

Example 2:
Input: rooms = [[-1]]
Output: [[-1]]

Example 3:
Input: rooms = [[2147483647]]
Output: [[2147483647]]

Example 4:
Input: rooms = [[0]]
Output: [[0]]

Constraints:
`m == rooms.length`
`n == rooms[i].length`
`1 <= m, n <= 250`
`rooms[i][j]` is `-1`, `0`, or `231 - 1`.",Medium,"def wallsAndGates(rooms):
    if not rooms or not rooms[0]:
        return

    m, n = len(rooms), len(rooms[0])
    INF = 2147483647

    # Directions for moving up, down, left, right
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    def bfs(gate_row, gate_col):
        queue = [(gate_row, gate_col, 0)]  # (row, col, distance)
        while queue:
            row, col, dist = queue.pop(0)
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                if 0 <= new_row < m and 0 <= new_col < n and rooms[new_row][new_col] == INF:
                    rooms[new_row][new_col] = dist + 1
                    queue.append((new_row, new_col, dist + 1))

    # Find all gates and start BFS from each gate
    for i in range(m):
        for j in range(n):
            if rooms[i][j] == 0:
                bfs(i, j)

# Example usage:
rooms1 = [
    [2147483647, -1, 0, 2147483647],
    [2147483647, 2147483647, 2147483647, -1],
    [2147483647, -1, 2147483647, -1],
    [0, -1, 2147483647, 2147483647]
]
wallsAndGates(rooms1)
print(rooms1)

rooms2 = [[-1]]
wallsAndGates(rooms2)
print(rooms2)

rooms3 = [[2147483647]]
wallsAndGates(rooms3)
print(rooms3)

rooms4 = [[0]]
wallsAndGates(rooms4)
print(rooms4)"
Longest Common Subsequence,"Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, `""ace""` is a subsequence of `""abcde""`.

A common subsequence of two strings is a subsequence that is common to both strings.


Example 1:
Input: text1 = ""abcde"", text2 = ""ace"" 
Output: 3  
Explanation: The longest common subsequence is ""ace"" and its length is 3.


Example 2:
Input: text1 = ""abc"", text2 = ""abc""
Output: 3
Explanation: The longest common subsequence is ""abc"" and its length is 3.


Example 3:
Input: text1 = ""abc"", text2 = ""def""
Output: 0
Explanation: There is no such common subsequence, so the result is 0.


Constraints:
`1 <= text1.length, text2.length <= 1000`
`text1` and `text2` consist of only lowercase English characters.",Medium,"def longestCommonSubsequence(text1, text2):
    # Get the lengths of the input strings
    m = len(text1)
    n = len(text2)
    
    # Create a 2D array to store the lengths of LCS
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill the dp array
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # The length of the longest common subsequence is in the bottom-right cell
    return dp[m][n]

# Example usage:
print(longestCommonSubsequence(""abcde"", ""ace""))  # Output: 3
print(longestCommonSubsequence(""abc"", ""abc""))    # Output: 3
print(longestCommonSubsequence(""abc"", ""def""))    # Output: 0"
Satisfiability of Equality Equations,"Given an array equations of strings that represent relationships between variables, each string `equations[i]` has length `4` and takes one of two different forms: `""a==b""` or `""a!=b""`.  Here, `a` and `b` are lowercase letters (not necessarily different) that represent one-letter variable names.

Return `true` if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.


Example 1:
Input: [""a==b"",""b!=a""]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.


Example 2:
Input: [""b==a"",""a==b""]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.


Example 3:
Input: [""a==b"",""b==c"",""a==c""]
Output: true

Example 4:
Input: [""a==b"",""b!=c"",""c==a""]
Output: false

Example 5:
Input: [""c==c"",""b==d"",""x!=z""]
Output: true
Note:
`1 <= equations.length <= 500`
`equations[i].length == 4`
`equations[i][0]` and `equations[i][3]` are lowercase letters
`equations[i][1]` is either `'='` or `'!'`
`equations[i][2]` is `'='`",Medium,"class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
    
    def find(self, x):
        # Path compression
        while x != self.parent[x]:
            self.parent[x] = self.parent[self.parent[x]]
            x = self.parent[x]
        return x
    
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.parent[rootY] = rootX

def equationsPossible(equations):
    uf = UnionFind(26)  # 26 letters in the alphabet
    
    # First pass: process all ""=="" equations
    for eq in equations:
        if eq[1] == '=':
            uf.union(ord(eq[0]) - ord('a'), ord(eq[3]) - ord('a'))
    
    # Second pass: process all ""!="" equations
    for eq in equations:
        if eq[1] == '!':
            if uf.find(ord(eq[0]) - ord('a')) == uf.find(ord(eq[3]) - ord('a')):
                return False
    
    return True

# Example usage:
print(equationsPossible([""a==b"", ""b!=a""]))  # Output: False
print(equationsPossible([""b==a"", ""a==b""]))  # Output: True
print(equationsPossible([""a==b"", ""b==c"", ""a==c""]))  # Output: True
print(equationsPossible([""a==b"", ""b!=c"", ""c==a""]))  # Output: False
print(equationsPossible([""c==c"", ""b==d"", ""x!=z""]))  # Output: True"
Check Completeness of a Binary Tree,"Given the `root` of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.


Example 2:
Input: root = [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.


Constraints:
The number of nodes in the tree is in the range `[1, 100]`.

`1 <= Node.val <= 1000`",Medium,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_complete_tree(root):
    if not root:
        return True
    
    # Initialize the queue with the root node
    queue = [root]
    end_of_complete = False
    
    while queue:
        node = queue.pop(0)
        
        if node.left:
            if end_of_complete:
                return False
            queue.append(node.left)
        else:
            end_of_complete = True
        
        if node.right:
            if end_of_complete:
                return False
            queue.append(node.right)
        else:
            end_of_complete = True
    
    return True

# Example usage:
# Construct the tree for example 1
root1 = TreeNode(1)
root1.left = TreeNode(2)
root1.right = TreeNode(3)
root1.left.left = TreeNode(4)
root1.left.right = TreeNode(5)
root1.right.left = TreeNode(6)

# Construct the tree for example 2
root2 = TreeNode(1)
root2.left = TreeNode(2)
root2.right = TreeNode(3)
root2.left.left = TreeNode(4)
root2.left.right = TreeNode(5)
root2.right.right = TreeNode(7)

print(is_complete_tree(root1))  # Output: True
print(is_complete_tree(root2))  # Output: False"
Maximum Number of Non-Overlapping Subarrays With Sum Equals Target,"Given an array `nums` and an integer `target`.

Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to `target`.


Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).


Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.

([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.


Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

Constraints:
`1 <= nums.length <= 10^5`
`-10^4 <= nums[i] <= 10^4`
`0 <= target <= 10^6`",Medium,"def maxNonOverlapping(nums, target):
    prefix_sum = 0
    seen_sums = set()
    count = 0
    
    for num in nums:
        prefix_sum += num
        
        # Check if the current prefix sum is equal to the target
        if prefix_sum == target:
            count += 1
            seen_sums.clear()  # Clear seen sums to ensure non-overlapping
        else:
            # Check if there is a previous prefix sum that makes the current subarray sum to target
            if prefix_sum - target in seen_sums:
                count += 1
                seen_sums.clear()  # Clear seen sums to ensure non-overlapping
        
        # Add the current prefix sum to the set of seen sums
        seen_sums.add(prefix_sum)
    
    return count

# Example usage:
print(maxNonOverlapping([1,1,1,1,1], 2))  # Output: 2
print(maxNonOverlapping([-1,3,5,1,4,2,-9], 6))  # Output: 2
print(maxNonOverlapping([-2,6,6,3,5,4,1,2,8], 10))  # Output: 3
print(maxNonOverlapping([0,0,0], 0))  # Output: 3"
Find Nearest Right Node in Binary Tree,"Given the `root` of a binary tree and a node `u` in the tree, return the nearest node on the same level that is to the right of `u`, or return `null` if `u` is the rightmost node in its level.


Example 1:
Input: root = [1,2,3,null,4,5,6], u = 4
Output: 5
Explanation: The nearest node on the same level to the right of node 4 is node 5.


Example 2:
Input: root = [3,null,4,2], u = 2
Output: null
Explanation: There are no nodes to the right of 2.


Example 3:
Input: root = [1], u = 1
Output: null

Example 4:
Input: root = [3,4,2,null,null,null,1], u = 4
Output: 2

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 105`
All values in the tree are distinct.

`u` is a node in the binary tree rooted at `root`.",Medium,"class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findNearestRightNode(root, u):
    if not root:
        return None
    
    # Initialize a queue for BFS
    queue = [root]
    
    while queue:
        level_size = len(queue)
        
        for i in range(level_size):
            node = queue.pop(0)
            
            # Check if the current node is u
            if node == u:
                # If u is not the last node in the current level, return the next node
                if i < level_size - 1:
                    return queue.pop(0)
                else:
                    return None
            
            # Enqueue left and right children
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    
    return None

# Example usage:
# Construct the tree for Example 1
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.right = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)

u = root.left.right  # Node with value 4
print(findNearestRightNode(root, u))  # Output: 5"
Put Boxes Into the Warehouse II,"You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labeled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.

Boxes are put into the warehouse by the following rules:
Boxes cannot be stacked.

You can rearrange the insertion order of the boxes.

Boxes can be pushed into the warehouse from either side (left or right)
If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.

Return the maximum number of boxes you can put into the warehouse.


Example 1:
Input: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]
Output: 4
Explanation:
We can store the boxes in the following order:
1- Put the yellow box in room 2 from either the left or right side.

2- Put the orange box in room 3 from the right side.

3- Put the green box in room 1 from the left side.

4- Put the red box in room 0 from the left side.

Notice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.


Example 2:
Input: boxes = [3,5,5,2], warehouse = [2,1,3,4,5]
Output: 3
Explanation:
It's not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.

Other valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes.


Example 3:
Input: boxes = [1,2,3], warehouse = [1,2,3,4]
Output: 3

Example 4:
Input: boxes = [4,5,6], warehouse = [3,3,3,3,3]
Output: 0

Constraints:
`n == warehouse.length`
`1 <= boxes.length, warehouse.length <= 105`
`1 <= boxes[i], warehouse[i] <= 109`",Medium,"def max_boxes_in_warehouse(boxes, warehouse):
    # Sort the boxes in ascending order
    boxes.sort()
    
    # Precompute the minimum height from the left and right for each room
    min_left = [float('inf')] * len(warehouse)
    min_right = [float('inf')] * len(warehouse)
    
    # Compute minimum heights from the left
    current_min = float('inf')
    for i in range(len(warehouse)):
        current_min = min(current_min, warehouse[i])
        min_left[i] = current_min
    
    # Compute minimum heights from the right
    current_min = float('inf')
    for i in range(len(warehouse) - 1, -1, -1):
        current_min = min(current_min, warehouse[i])
        min_right[i] = current_min
    
    # Two pointers for the warehouse
    left = 0
    right = len(warehouse) - 1
    
    # Counter for the number of boxes placed
    placed_boxes = 0
    
    # Try to place each box
    for box in boxes:
        # Try placing the box from the left side
        while left <= right and box > min_left[left]:
            left += 1
        
        # If the box can be placed from the left, place it and move the pointer
        if left <= right:
            placed_boxes += 1
            left += 1
            continue
        
        # Try placing the box from the right side
        while left <= right and box > min_right[right]:
            right -= 1
        
        # If the box can be placed from the right, place it and move the pointer
        if left <= right:
            placed_boxes += 1
            right -= 1
    
    return placed_boxes

# Example usage:
print(max_boxes_in_warehouse([1, 2, 2, 3, 4], [3, 4, 1, 2]))  # Output: 4
print(max_boxes_in_warehouse([3, 5, 5, 2], [2, 1, 3, 4, 5]))  # Output: 3
print(max_boxes_in_warehouse([1, 2, 3], [1, 2, 3, 4]))  # Output: 3
print(max_boxes_in_warehouse([4, 5, 6], [3, 3, 3, 3, 3]))  # Output: 0"
Minimum Swaps to Group All 1's Together,"Given a binary array `data`, return the minimum number of swaps required to group all `1`’s present in the array together in any place in the array.


Example 1:
Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.

[0,1,1,1,0] using 2 swaps.

[0,0,1,1,1] using 1 swap.

The minimum is 1.


Example 2:
Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


Example 3:
Input: data = [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: 
One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].


Example 4:
Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
Output: 8

Constraints:
`1 <= data.length <= 105`
`data[i]` is `0` or `1`.",Medium,"def min_swaps_to_group_ones(data):
    # Step 1: Count the total number of 1's in the array
    total_ones = 0
    for num in data:
        if num == 1:
            total_ones += 1
    
    # If there are no 1's or only one 1, no swaps are needed
    if total_ones <= 1:
        return 0
    
    # Step 2: Initialize the sliding window
    window_size = total_ones
    max_zeros_in_window = 0
    current_zeros = 0
    
    # Step 3: Slide the window across the array
    for i in range(len(data)):
        # Add the current element to the window
        if data[i] == 0:
            current_zeros += 1
        
        # Remove the element that is left behind as the window slides
        if i >= window_size:
            if data[i - window_size] == 0:
                current_zeros -= 1
        
        # Update the maximum number of zeros found in any window
        max_zeros_in_window = max(max_zeros_in_window, current_zeros)
    
    # Step 4: The minimum number of swaps needed is the maximum number of zeros in any window
    return max_zeros_in_window

# Example usage:
print(min_swaps_to_group_ones([1, 0, 1, 0, 1]))  # Output: 1
print(min_swaps_to_group_ones([0, 0, 0, 1, 0]))  # Output: 0
print(min_swaps_to_group_ones([1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1]))  # Output: 3
print(min_swaps_to_group_ones([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1]))  # Output: 8"
Minimum Remove to Make Valid Parentheses,"Given a string s of `'('` , `')'` and lowercase English characters. 
Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or
It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
It can be written as `(A)`, where `A` is a valid string.


Example 1:
Input: s = ""lee(t(c)o)de)""
Output: ""lee(t(c)o)de""
Explanation: ""lee(t(co)de)"" , ""lee(t(c)ode)"" would also be accepted.


Example 2:
Input: s = ""a)b(c)d""
Output: ""ab(c)d""

Example 3:
Input: s = ""))((""
Output: """"
Explanation: An empty string is also valid.


Example 4:
Input: s = ""(a(b(c)d)""
Output: ""a(b(c)d)""

Constraints:
`1 <= s.length <= 10^5`
`s[i]` is one of  `'('` , `')'` and lowercase English letters`.`",Medium,"def minRemoveToMakeValid(s):
    # First pass: Remove unmatched ')'
    result = []
    open_count = 0
    for char in s:
        if char == '(':
            open_count += 1
            result.append(char)
        elif char == ')':
            if open_count > 0:
                open_count -= 1
                result.append(char)
        else:
            result.append(char)

    # Second pass: Remove unmatched '('
    final_result = []
    close_count = 0
    for char in reversed(result):
        if char == ')':
            close_count += 1
            final_result.append(char)
        elif char == '(':
            if close_count > 0:
                close_count -= 1
                final_result.append(char)
        else:
            final_result.append(char)

    # The result is built in reverse order, so reverse it back
    final_result.reverse()
    return ''.join(final_result)

# Example usage:
print(minRemoveToMakeValid(""lee(t(c)o)de)""))  # Output: ""lee(t(c)o)de""
print(minRemoveToMakeValid(""a)b(c)d""))       # Output: ""ab(c)d""
print(minRemoveToMakeValid(""))((""))          # Output: """"
print(minRemoveToMakeValid(""(a(b(c)d)""))     # Output: ""a(b(c)d)"""
Trapping Rain Water,"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.


Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.


Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
`n == height.length`
`0 <= n <= 3 * 104`
`0 <= height[i] <= 105`",Hard,"def trap(height):
    if not height:
        return 0

    n = len(height)
    left_max = [0] * n
    right_max = [0] * n

    # Fill left_max array
    left_max[0] = height[0]
    for i in range(1, n):
        left_max[i] = max(left_max[i - 1], height[i])

    # Fill right_max array
    right_max[n - 1] = height[n - 1]
    for i in range(n - 2, -1, -1):
        right_max[i] = max(right_max[i + 1], height[i])

    # Calculate trapped water
    trapped_water = 0
    for i in range(n):
        water_level = min(left_max[i], right_max[i])
        trapped_water += max(water_level - height[i], 0)

    return trapped_water

# Example usage:
height1 = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
print(trap(height1))  # Output: 6

height2 = [4, 2, 0, 3, 2, 5]
print(trap(height2))  # Output: 9"
Minimum Cost to Make at Least One Valid Path in a Grid,"Given a m x n `grid`. Each cell of the `grid` has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:
1 which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)
2 which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)
3 which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)
4 which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)
Notice that there could be some invalid signs on the cells of the `grid` which points outside the `grid`.

You will initially start at the upper left cell `(0,0)`. A valid path in the grid is a path which starts from the upper left cell `(0,0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.


Example 1:
Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).

The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.


Example 2:
Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).


Example 3:
Input: grid = [[1,2],[4,3]]
Output: 1

Example 4:
Input: grid = [[2,2,2],[2,2,2]]
Output: 3

Example 5:
Input: grid = [[4]]
Output: 0

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`",Hard,"def minCost(grid):
    import heapq
    
    m, n = len(grid), len(grid[0])
    
    # Directions for right, left, down, up
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # Priority queue to store (cost, i, j)
    pq = [(0, 0, 0)]
    
    # Distance array to store minimum cost to reach each cell
    dist = [[float('inf')] * n for _ in range(m)]
    dist[0][0] = 0
    
    while pq:
        cost, i, j = heapq.heappop(pq)
        
        # If we reached the bottom-right cell, return the cost
        if i == m - 1 and j == n - 1:
            return cost
        
        # Explore neighbors
        for d, (di, dj) in enumerate(directions):
            ni, nj = i + di, j + dj
            
            # Check if the neighbor is within bounds
            if 0 <= ni < m and 0 <= nj < n:
                # Calculate the new cost
                new_cost = cost + (1 if d != grid[i][j] - 1 else 0)
                
                # If the new cost is less than the stored cost, update and push to queue
                if new_cost < dist[ni][nj]:
                    dist[ni][nj] = new_cost
                    heapq.heappush(pq, (new_cost, ni, nj))
    
    # If we cannot reach the bottom-right cell, return -1 (though the problem guarantees a solution)
    return -1

# Example usage:
grid1 = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
grid2 = [[1,1,3],[3,2,2],[1,1,4]]
grid3 = [[1,2],[4,3]]
grid4 = [[2,2,2],[2,2,2]]
grid5 = [[4]]

print(minCost(grid1))  # Output: 3
print(minCost(grid2))  # Output: 0
print(minCost(grid3))  # Output: 1
print(minCost(grid4))  # Output: 3
print(minCost(grid5))  # Output: 0"
Pizza With 3n Slices,"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:
You will pick any pizza slice.

Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.

Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.


Example 1:
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.


Example 2:
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.

Example 3:
Input: slices = [4,1,2,5,8,3,1,9,7]
Output: 21

Example 4:
Input: slices = [3,1,2]
Output: 3

Constraints:
`1 <= slices.length <= 500`
`slices.length % 3 == 0`
`1 <= slices[i] <= 1000`",Hard,"def maxSizeSlices(slices):
    def maxSum(slices, n, k):
        # Initialize DP table
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        
        # Fill the DP table
        for i in range(1, n + 1):
            for j in range(1, k + 1):
                # Option 1: Do not take the current slice
                dp[i][j] = dp[i - 1][j]
                # Option 2: Take the current slice, but skip the previous one
                if i > 1:
                    dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + slices[i - 1])
        
        return dp[n][k]
    
    n = len(slices)
    k = n // 3
    
    # Calculate the maximum sum excluding the first slice
    max1 = maxSum(slices[1:], n - 1, k)
    
    # Calculate the maximum sum excluding the last slice
    max2 = maxSum(slices[:-1], n - 1, k)
    
    # Return the maximum of the two results
    return max(max1, max2)

# Example usage:
print(maxSizeSlices([1, 2, 3, 4, 5, 6]))  # Output: 10
print(maxSizeSlices([8, 9, 8, 6, 1, 1]))  # Output: 16
print(maxSizeSlices([4, 1, 2, 5, 8, 3, 1, 9, 7]))  # Output: 21
print(maxSizeSlices([3, 1, 2]))  # Output: 3"
Number of Ways to Wear Different Hats to Each Other,"There are `n` people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers `hats`, where `hats[i]` is a list of all hats preferred by the i-th` person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.


Example 2:
Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats
(3,5), (5,3), (1,3) and (1,5)

Example 3:
Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.

Number of Permutations of (1,2,3,4) = 24.


Example 4:
Input: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
Output: 111

Constraints:
`n == hats.length`
`1 <= n <= 10`
`1 <= hats[i].length <= 40`
`1 <= hats[i][j] <= 40`
`hats[i]` contains a list of unique integers.",Hard,"def numberWays(hats):
    MOD = 10**9 + 7
    n = len(hats)
    
    # Create a list of people who like each hat
    hat_to_people = [[] for _ in range(41)]
    for i in range(n):
        for hat in hats[i]:
            hat_to_people[hat].append(i)
    
    # Initialize the DP table
    dp = [[0] * 41 for _ in range(1 << n)]
    dp[0][0] = 1
    
    # Fill the DP table
    for hat in range(1, 41):
        for mask in range(1 << n):
            dp[mask][hat] = dp[mask][hat - 1]
            for person in hat_to_people[hat]:
                if mask & (1 << person) == 0:
                    new_mask = mask | (1 << person)
                    dp[new_mask][hat] = (dp[new_mask][hat] + dp[mask][hat - 1]) % MOD
    
    # The result is the number of ways to assign hats to all people using all hats
    return dp[(1 << n) - 1][40]

# Example usage:
print(numberWays([[3,4],[4,5],[5]]))  # Output: 1
print(numberWays([[3,5,1],[3,5]]))     # Output: 4
print(numberWays([[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]))  # Output: 24
print(numberWays([[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]))  # Output: 111"
Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an `m * n` matrix, `mat`, and an integer `k`, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.


Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.  

Example 2:
Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17

Example 3:
Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  

Example 4:
Input: mat = [[1,1,10],[2,2,9]], k = 7
Output: 12

Constraints:
`m == mat.length`
`n == mat.length[i]`
`1 <= m, n <= 40`
`1 <= k <= min(200, n ^ m)`
`1 <= mat[i][j] <= 5000`
`mat[i]` is a non decreasing array.",Hard,"class Solution:
    def kthSmallest(self, mat, k):
        import heapq
        
        # Initialize the heap with the first row of the matrix
        heap = [(num, 0) for num in mat[0]]
        heapq.heapify(heap)
        
        # Process each row starting from the second row
        for i in range(1, len(mat)):
            new_heap = []
            while heap and len(new_heap) < k:
                current_sum, col_index = heapq.heappop(heap)
                for j in range(len(mat[i])):
                    new_sum = current_sum + mat[i][j]
                    if len(new_heap) < k:
                        heapq.heappush(new_heap, (new_sum, j))
                    elif new_sum > new_heap[0][0]:
                        break
            heap = new_heap
        
        # The k-th smallest sum will be the k-th element in the heap
        return heap[k-1][0]

# Example usage:
sol = Solution()
print(sol.kthSmallest([[1,3,11],[2,4,6]], 5))  # Output: 7
print(sol.kthSmallest([[1,3,11],[2,4,6]], 9))  # Output: 17
print(sol.kthSmallest([[1,10,10],[1,4,5],[2,3,6]], 7))  # Output: 9
print(sol.kthSmallest([[1,1,10],[2,2,9]], 7))  # Output: 12"
Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:
Type 1: Can be traversed by Alice only.

Type 2: Can be traversed by Bob only.

Type 3: Can by traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.


Example 1:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.


Example 2:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.


Example 3:
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.


Constraints:
`1 <= n <= 10^5`
`1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
`edges[i].length == 3`
`1 <= edges[i][0] <= 3`
`1 <= edges[i][1] < edges[i][2] <= n`
All tuples `(typei, ui, vi)` are distinct.",Hard,"class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n

    def find(self, u):
        if self.parent[u] != u:
            self.parent[u] = self.find(self.parent[u])
        return self.parent[u]

    def union(self, u, v):
        rootU = self.find(u)
        rootV = self.find(v)
        if rootU == rootV:
            return False
        if self.rank[rootU] > self.rank[rootV]:
            self.parent[rootV] = rootU
        elif self.rank[rootU] < self.rank[rootV]:
            self.parent[rootU] = rootV
        else:
            self.parent[rootV] = rootU
            self.rank[rootU] += 1
        self.components -= 1
        return True

def maxNumEdgesToRemove(n, edges):
    aliceUF = UnionFind(n)
    bobUF = UnionFind(n)
    
    redundant_edges = 0
    
    # Process type 3 edges first
    for edge in edges:
        if edge[0] == 3:
            if not aliceUF.union(edge[1] - 1, edge[2] - 1):
                redundant_edges += 1
            if not bobUF.union(edge[1] - 1, edge[2] - 1):
                redundant_edges += 1
    
    # Process type 1 edges
    for edge in edges:
        if edge[0] == 1:
            if not aliceUF.union(edge[1] - 1, edge[2] - 1):
                redundant_edges += 1
    
    # Process type 2 edges
    for edge in edges:
        if edge[0] == 2:
            if not bobUF.union(edge[1] - 1, edge[2] - 1):
                redundant_edges += 1
    
    # Check if both Alice and Bob can traverse the entire graph
    if aliceUF.components == 1 and bobUF.components == 1:
        return redundant_edges
    else:
        return -1

# Example usage:
print(maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]))  # Output: 2
print(maxNumEdgesToRemove(4, [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]))  # Output: 0
print(maxNumEdgesToRemove(4, [[3,2,3],[1,1,2],[2,3,4]]))  # Output: -1"
Minimum Operations to Make a Subsequence,"You are given an array `target` that consists of distinct integers and another integer array `arr` that can have duplicates.

In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make `target` a subsequence of `arr`.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.


Example 1:
Input: target = [5,1,3], `arr` = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`.


Example 2:
Input: target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1]
Output: 3

Constraints:
`1 <= target.length, arr.length <= 105`
`1 <= target[i], arr[i] <= 109`
`target` contains no duplicates.",Hard,"def min_operations_to_subsequence(target, arr):
    # Step 1: Create a mapping from target elements to their indices
    target_index_map = {}
    for i, num in enumerate(target):
        target_index_map[num] = i
    
    # Step 2: Transform arr into a sequence of indices based on target_index_map
    transformed_arr = []
    for num in arr:
        if num in target_index_map:
            transformed_arr.append(target_index_map[num])
    
    # Step 3: Find the LIS in the transformed sequence
    def find_lis(sequence):
        if not sequence:
            return 0
        
        # This will store the smallest tail of all increasing subsequences
        # with different lengths
        lis = []
        
        for num in sequence:
            pos = binary_search(lis, num)
            if pos == len(lis):
                lis.append(num)
            else:
                lis[pos] = num
        
        return len(lis)
    
    def binary_search(lis, num):
        low, high = 0, len(lis)
        while low < high:
            mid = (low + high) // 2
            if lis[mid] < num:
                low = mid + 1
            else:
                high = mid
        return low
    
    lis_length = find_lis(transformed_arr)
    
    # Step 4: Calculate the minimum number of operations
    return len(target) - lis_length

# Example usage:
print(min_operations_to_subsequence([5, 1, 3], [9, 4, 2, 3, 4]))  # Output: 2
print(min_operations_to_subsequence([6, 4, 8, 1, 3, 2], [4, 7, 6, 2, 3, 8, 6, 1]))  # Output: 3"
Edit Distance,"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.

You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character

Example 1:
Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

Constraints:
`0 <= word1.length, word2.length <= 500`
`word1` and `word2` consist of lowercase English letters.",Hard,"def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    
    # Initialize the DP table
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Base cases
    for i in range(1, m + 1):
        dp[i][0] = i
    for j in range(1, n + 1):
        dp[0][j] = j
    
    # Fill the DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j],    # Delete
                               dp[i][j - 1],    # Insert
                               dp[i - 1][j - 1]) # Replace
                dp[i][j] += 1
    
    return dp[m][n]

# Example usage:
print(minDistance(""horse"", ""ros""))  # Output: 3
print(minDistance(""intention"", ""execution""))  # Output: 5"
Maximum Profit in Job Scheduling,"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.


Example 1:
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.


Example 2:
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.


Example 3:
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6

Constraints:
`1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
`1 <= startTime[i] < endTime[i] <= 109`
`1 <= profit[i] <= 104`",Hard,"def jobScheduling(startTime, endTime, profit):
    # Combine and sort jobs based on start times
    jobs = [(startTime[i], endTime[i], profit[i]) for i in range(len(startTime))]
    jobs.sort()

    # Initialize dp array
    n = len(jobs)
    dp = [0] * n
    dp[0] = jobs[0][2]

    # Function to perform binary search
    def binary_search(end):
        low, high = 0, n - 1
        while low < high:
            mid = (low + high) // 2
            if jobs[mid][1] <= end:
                low = mid + 1
            else:
                high = mid
        return low - 1

    # Fill dp array
    for i in range(1, n):
        # Profit if the current job is included
        include_profit = jobs[i][2]
        last_compatible_job_index = binary_search(jobs[i][0])
        if last_compatible_job_index >= 0:
            include_profit += dp[last_compatible_job_index]

        # Profit if the current job is excluded
        exclude_profit = dp[i - 1]

        # Update dp[i]
        dp[i] = max(include_profit, exclude_profit)

    # The maximum profit is the last element in dp array
    return dp[-1]

# Example usage:
print(jobScheduling([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70]))  # Output: 120
print(jobScheduling([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60]))  # Output: 150
print(jobScheduling([1, 1, 1], [2, 3, 4], [5, 6, 4]))  # Output: 6"
Cherry Pickup II,"Given a `rows x cols` matrix `grid` representing a field of cherries. Each cell in `grid` represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:
From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).

When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).

When both robots stay on the same cell, only one of them takes the cherries.

Both robots cannot move outside of the grid at any moment.

Both robots should reach the bottom row in the `grid`.


Example 1:
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.

Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.

Total of cherries: 12 + 12 = 24.


Example 2:
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.

Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.

Total of cherries: 17 + 11 = 28.


Example 3:
Input: grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
Output: 22

Example 4:
Input: grid = [[1,1],[1,1]]
Output: 4

Constraints:
`rows == grid.length`
`cols == grid[i].length`
`2 <= rows, cols <= 70`
`0 <= grid[i][j] <= 100 `",Hard,"def cherryPickup(grid):
    rows = len(grid)
    cols = len(grid[0])
    
    # Initialize the DP table with -1
    dp = [[[-1] * cols for _ in range(cols)] for _ in range(rows)]
    
    # Base case
    dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1]
    
    # Directions for moving down
    directions = [(-1, -1), (-1, 0), (-1, 1)]
    
    # Fill the DP table
    for r in range(1, rows):
        for c1 in range(cols):
            for c2 in range(cols):
                if dp[r-1][c1][c2] == -1:
                    continue
                for d1 in directions:
                    for d2 in directions:
                        nc1 = c1 + d1[1]
                        nc2 = c2 + d2[1]
                        if 0 <= nc1 < cols and 0 <= nc2 < cols:
                            cherries = grid[r][nc1] + grid[r][nc2]
                            if nc1 == nc2:
                                cherries -= grid[r][nc1]
                            dp[r][nc1][nc2] = max(dp[r][nc1][nc2], dp[r-1][c1][c2] + cherries)
    
    # Find the maximum cherries collected in the last row
    max_cherries = 0
    for c1 in range(cols):
        for c2 in range(cols):
            max_cherries = max(max_cherries, dp[rows-1][c1][c2])
    
    return max_cherries

# Example usage:
grid1 = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
print(cherryPickup(grid1))  # Output: 24

grid2 = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
print(cherryPickup(grid2))  # Output: 28

grid3 = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
print(cherryPickup(grid3))  # Output: 22

grid4 = [[1,1],[1,1]]
print(cherryPickup(grid4))  # Output: 4"
