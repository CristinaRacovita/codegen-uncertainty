title,description,difficulty,solution
Relative Ranks,"You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:
The `1st` place athlete's rank is `""Gold Medal""`.

The `2nd` place athlete's rank is `""Silver Medal""`.

The `3rd` place athlete's rank is `""Bronze Medal""`.

For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `""x""`).

Return an array `answer` of size `n` where `answer[i]` is the rank of the `ith` athlete.


Example 1:
Input: score = [5,4,3,2,1]
Output: [""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].


Example 2:
Input: score = [10,3,8,9,4]
Output: [""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].


Constraints:
`n == score.length`
`1 <= n <= 104`
`0 <= score[i] <= 106`
All the values in `score` are unique.",Easy,"using System;

public class Solution
{
    public string[] FindRelativeRanks(int[] score)
    {
        int n = score.Length;
        string[] answer = new string[n];
        
        // Step 1: Create a sorted copy of the scores
        int[] sortedScores = new int[n];
        for (int i = 0; i < n; i++)
        {
            sortedScores[i] = score[i];
        }
        
        // Simple bubble sort to sort the scores in descending order
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < n - i - 1; j++)
            {
                if (sortedScores[j] < sortedScores[j + 1])
                {
                    int temp = sortedScores[j];
                    sortedScores[j] = sortedScores[j + 1];
                    sortedScores[j + 1] = temp;
                }
            }
        }
        
        // Step 2: Assign ranks
        string[] ranks = new string[n];
        ranks[0] = ""Gold Medal"";
        if (n > 1) ranks[1] = ""Silver Medal"";
        if (n > 2) ranks[2] = ""Bronze Medal"";
        for (int i = 3; i < n; i++)
        {
            ranks[i] = (i + 1).ToString();
        }
        
        // Step 3: Map scores to ranks
        string[] rankMap = new string[1000001]; // Assuming scores are within 0 to 10^6
        for (int i = 0; i < n; i++)
        {
            rankMap[sortedScores[i]] = ranks[i];
        }
        
        // Step 4: Construct the result
        for (int i = 0; i < n; i++)
        {
            answer[i] = rankMap[score[i]];
        }
        
        return answer;
    }
}"
Truncate Sentence,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, `""Hello World""`, `""HELLO""`, and `""hello world hello world""` are all sentences.

You are given a sentence `s`​​​​​​ and an integer `k`​​​​​​. You want to truncate `s`​​​​​​ such that it contains only the first `k`​​​​​​ words. Return `s`​​​​​​ after truncating it.


Example 1:
Input: s = ""Hello how are you Contestant"", k = 4
Output: ""Hello how are you""
Explanation:
The words in s are [""Hello"", ""how"" ""are"", ""you"", ""Contestant""].

The first 4 words are [""Hello"", ""how"", ""are"", ""you""].

Hence, you should return ""Hello how are you"".


Example 2:
Input: s = ""What is the solution to this problem"", k = 4
Output: ""What is the solution""
Explanation:
The words in s are [""What"", ""is"" ""the"", ""solution"", ""to"", ""this"", ""problem""].

The first 4 words are [""What"", ""is"", ""the"", ""solution""].

Hence, you should return ""What is the solution"".


Example 3:
Input: s = ""chopper is not a tanuki"", k = 5
Output: ""chopper is not a tanuki""

Constraints:
`1 <= s.length <= 500`
`k` is in the range `[1, the number of words in s]`.

`s` consist of only lowercase and uppercase English letters and spaces.

The words in `s` are separated by a single space.

There are no leading or trailing spaces.",Easy,"public class Solution {
    public string TruncateSentence(string s, int k) {
        int length = s.Length;
        int spaceCount = 0;
        
        // Traverse the string to find the end of the k-th word
        for (int i = 0; i < length; i++) {
            if (s[i] == ' ') {
                spaceCount++;
                // If we have found k spaces, return the substring up to the current position
                if (spaceCount == k) {
                    return s.Substring(0, i);
                }
            }
        }
        
        // If k is equal to the number of words in the sentence, return the whole sentence
        return s;
    }
}"
Perform String Shifts,"You are given a string `s` containing lowercase English letters, and a matrix `shift`, where `shift[i] = [direction, amount]`:
`direction` can be `0` (for left shift) or `1` (for right shift). 
`amount` is the amount by which string `s` is to be shifted.

A left shift by 1 means remove the first character of `s` and append it to the end.

Similarly, a right shift by 1 means remove the last character of `s` and add it to the beginning.

Return the final string after all operations.


Example 1:
Input: s = ""abc"", shift = [[0,1],[1,2]]
Output: ""cab""
Explanation: 
[0,1] means shift to left by 1. ""abc"" -> ""bca""
[1,2] means shift to right by 2. ""bca"" -> ""cab""

Example 2:
Input: s = ""abcdefg"", shift = [[1,1],[1,1],[0,2],[1,3]]
Output: ""efgabcd""
Explanation:  
[1,1] means shift to right by 1. ""abcdefg"" -> ""gabcdef""
[1,1] means shift to right by 1. ""gabcdef"" -> ""fgabcde""
[0,2] means shift to left by 2. ""fgabcde"" -> ""abcdefg""
[1,3] means shift to right by 3. ""abcdefg"" -> ""efgabcd""

Constraints:
`1 <= s.length <= 100`
`s` only contains lower case English letters.

`1 <= shift.length <= 100`
`shift[i].length == 2`
`0 <= shift[i][0] <= 1`
`0 <= shift[i][1] <= 100`",Easy,"using System;

public class Solution {
    public string StringShift(string s, int[][] shift) {
        int netShift = 0;
        
        // Calculate net shift
        foreach (var sh in shift) {
            if (sh[0] == 0) {
                netShift -= sh[1]; // Left shift
            } else {
                netShift += sh[1]; // Right shift
            }
        }
        
        // Normalize net shift
        netShift = (netShift + s.Length) % s.Length;
        
        // If net shift is zero, return the original string
        if (netShift == 0) {
            return s;
        }
        
        // Perform the shift
        char[] result = new char[s.Length];
        int n = s.Length;
        
        if (netShift > 0) {
            // Right shift
            for (int i = 0; i < n; i++) {
                result[(i + netShift) % n] = s[i];
            }
        } else {
            // Left shift
            for (int i = 0; i < n; i++) {
                result[(i - netShift + n) % n] = s[i];
            }
        }
        
        return new string(result);
    }
    
    public static void Main(string[] args) {
        Solution solution = new Solution();
        
        // Test cases
        Console.WriteLine(solution.StringShift(""abc"", new int[][] { new int[] { 0, 1 }, new int[] { 1, 2 } })); // Output: ""cab""
        Console.WriteLine(solution.StringShift(""abcdefg"", new int[][] { new int[] { 1, 1 }, new int[] { 1, 1 }, new int[] { 0, 2 }, new int[] { 1, 3 } })); // Output: ""efgabcd""
    }
}"
Invert Binary Tree,"Given the `root` of a binary tree, invert the tree, and return its root.


Example 1:
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

Example 2:
Input: root = [2,1,3]
Output: [2,3,1]

Example 3:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree is in the range `[0, 100]`.

`-100 <= Node.val <= 100`",Easy,"public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x) { val = x; }
}

public class Solution {
    public TreeNode InvertTree(TreeNode root) {
        // Base case: if the current node is null, return null
        if (root == null) {
            return null;
        }

        // Swap the left and right children
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;

        // Recursively invert the left subtree
        InvertTree(root.left);

        // Recursively invert the right subtree
        InvertTree(root.right);

        // Return the root of the inverted tree
        return root;
    }
}"
Merge Strings Alternately,"You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.


Example 1:
Input: word1 = ""abc"", word2 = ""pqr""
Output: ""apbqcr""
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r

Example 2:
Input: word1 = ""ab"", word2 = ""pqrs""
Output: ""apbqrs""
Explanation: Notice that as word2 is longer, ""rs"" is appended to the end.

word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s

Example 3:
Input: word1 = ""abcd"", word2 = ""pq""
Output: ""apbqcd""
Explanation: Notice that as word1 is longer, ""cd"" is appended to the end.

word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d

Constraints:
`1 <= word1.length, word2.length <= 100`
`word1` and `word2` consist of lowercase English letters.",Easy,"using System;

class Program
{
    static void Main()
    {
        string word1 = ""abc"";
        string word2 = ""pqr"";
        Console.WriteLine(MergeStrings(word1, word2)); // Output: ""apbqcr""

        word1 = ""ab"";
        word2 = ""pqrs"";
        Console.WriteLine(MergeStrings(word1, word2)); // Output: ""apbqrs""

        word1 = ""abcd"";
        word2 = ""pq"";
        Console.WriteLine(MergeStrings(word1, word2)); // Output: ""apbqcd""
    }

    static string MergeStrings(string word1, string word2)
    {
        int length1 = GetStringLength(word1);
        int length2 = GetStringLength(word2);
        int maxLength = length1 > length2 ? length1 : length2;
        char[] mergedArray = new char[length1 + length2];

        for (int i = 0; i < maxLength; i++)
        {
            if (i < length1)
            {
                mergedArray[i * 2] = word1[i];
            }
            if (i < length2)
            {
                mergedArray[i * 2 + 1] = word2[i];
            }
        }

        return new string(mergedArray);
    }

    static int GetStringLength(string str)
    {
        int length = 0;
        while (str[length] != '\0')
        {
            length++;
        }
        return length;
    }
}"
Delete N Nodes After M Nodes of a Linked List,"Given the `head` of a linked list and two integers `m` and `n`. Traverse the linked list and remove some nodes in the following way:
Start with the head as the current node.

Keep the first `m` nodes starting with the current node.

Remove the next `n` nodes
Keep repeating steps 2 and 3 until you reach the end of the list.

Return the head of the modified list after removing the mentioned nodes.

Follow up question: How can you solve this problem by modifying the list in-place?

Example 1:
Input: head = [1,2,3,4,5,6,7,8,9,10,11,12,13], m = 2, n = 3
Output: [1,2,6,7,11,12]
Explanation: Keep the first (m = 2) nodes starting from the head of the linked List  (1 ->2) show in black nodes.

Delete the next (n = 3) nodes (3 -> 4 -> 5) show in read nodes.

Continue with the same procedure until reaching the tail of the Linked List.

Head of linked list after removing nodes is returned.


Example 2:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 1, n = 3
Output: [1,5,9]
Explanation: Head of linked list after removing nodes is returned.


Example 3:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 3, n = 1
Output: [1,2,3,5,6,7,9,10,11]

Example 4:
Input: head = [9,3,7,7,9,10,8,2], m = 1, n = 2
Output: [9,7,8]

Constraints:
The given linked list will contain between `1` and `10^4` nodes.

The value of each node in the linked list will be in the range` [1, 10^6]`.

`1 <= m,n <= 1000`",Easy,"public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int val = 0, ListNode next = null) {
        this.val = val;
        this.next = next;
    }
}

public class Solution {
    public ListNode DeleteNodes(ListNode head, int m, int n) {
        if (head == null) return null;

        ListNode current = head;
        ListNode prev = null;

        while (current != null) {
            // Keep m nodes
            for (int i = 0; i < m && current != null; i++) {
                if (prev == null) {
                    prev = current;
                } else {
                    prev.next = current;
                    prev = current;
                }
                current = current.next;
            }

            // Remove n nodes
            for (int i = 0; i < n && current != null; i++) {
                current = current.next;
            }

            // Link the remaining nodes
            if (prev != null) {
                prev.next = current;
            }
        }

        return head;
    }
}"
Reverse Linked List,"Given the `head` of a singly linked list, reverse the list, and return the reversed list.


Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:
Input: head = [1,2]
Output: [2,1]

Example 3:
Input: head = []
Output: []

Constraints:
The number of nodes in the list is the range `[0, 5000]`.

`-5000 <= Node.val <= 5000`
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",Easy,"public class ListNode
{
    public int val;
    public ListNode next;
    public ListNode(int val = 0, ListNode next = null)
    {
        this.val = val;
        this.next = next;
    }
}

public class Solution
{
    public ListNode ReverseListIterative(ListNode head)
    {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null)
        {
            ListNode nextNode = current.next; // Store the next node
            current.next = prev;              // Reverse the link
            prev = current;                   // Move prev to current
            current = nextNode;               // Move to the next node
        }
        
        return prev; // New head of the reversed list
    }
}"
How Many Numbers Are Smaller Than the Current Number,"Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j's` such that `j != i` and `nums[j] < nums[i]`.

Return the answer in an array.


Example 1:
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.

For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).


Example 2:
Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Example 3:
Input: nums = [7,7,7,7]
Output: [0,0,0,0]

Constraints:
`2 <= nums.length <= 500`
`0 <= nums[i] <= 100`",Easy,"public class Solution {
    public int[] SmallerNumbersThanCurrent(int[] nums) {
        int n = nums.Length;
        int[] result = new int[n];
        
        for (int i = 0; i < n; i++) {
            int count = 0;
            for (int j = 0; j < n; j++) {
                if (i != j && nums[j] < nums[i]) {
                    count++;
                }
            }
            result[i] = count;
        }
        
        return result;
    }
}"
Find All The Lonely Nodes,"In a binary tree, a lonely node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.

Given the `root` of a binary tree, return an array containing the values of all lonely nodes in the tree. Return the list in any order.


Example 1:
Input: root = [1,2,3,null,4]
Output: [4]
Explanation: Light blue node is the only lonely node.

Node 1 is the root and is not lonely.

Nodes 2 and 3 have the same parent and are not lonely.


Example 2:
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
Output: [6,2]
Explanation: Light blue nodes are lonely nodes.

Please remember that order doesn't matter, [2,6] is also an acceptable answer.


Example 3:
Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
Output: [77,55,33,66,44,22]
Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.

All other nodes are lonely.


Example 4:
Input: root = [197]
Output: []

Example 5:
Input: root = [31,null,78,null,28]
Output: [78,28]

Constraints:
The number of nodes in the `tree` is in the range `[1, 1000].`
Each node's value is between `[1, 10^6]`.",Easy,"using System;
using System.Collections.Generic;

public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public class Solution {
    private List<int> lonelyNodes = new List<int>();

    public int[] GetLonelyNodes(TreeNode root) {
        if (root == null) {
            return new int[0];
        }

        // Start DFS from the root
        Dfs(root, false);

        // Convert the list to an array
        int[] result = new int[lonelyNodes.Count];
        for (int i = 0; i < lonelyNodes.Count; i++) {
            result[i] = lonelyNodes[i];
        }

        return result;
    }

    private void Dfs(TreeNode node, bool hasSibling) {
        if (node == null) {
            return;
        }

        // If the current node is lonely, add its value to the list
        if (!hasSibling && (node.left != null || node.right != null)) {
            lonelyNodes.Add(node.val);
        }

        // Recursively traverse the left and right children
        Dfs(node.left, node.right != null);
        Dfs(node.right, node.left != null);
    }

    public static void Main(string[] args) {
        // Example usage
        Solution solution = new Solution();
        
        // Construct the tree for example 1
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        root1.left.right = new TreeNode(4);
        
        int[] result1 = solution.GetLonelyNodes(root1);
        Console.WriteLine(""Example 1: "" + string.Join("", "", result1)); // Output: 4

        // Construct the tree for example 2
        TreeNode root2 = new TreeNode(7);
        root2.left = new TreeNode(1);
        root2.right = new TreeNode(4);
        root2.left.left = new TreeNode(6);
        root2.right.left = new TreeNode(5);
        root2.right.right = new TreeNode(3);
        root2.right.left.left = new TreeNode(2);
        
        int[] result2 = solution.GetLonelyNodes(root2);
        Console.WriteLine(""Example 2: "" + string.Join("", "", result2)); // Output: 6, 2
    }
}"
Maximum Ascending Subarray Sum,"Given an array of positive integers `nums`, return the maximum possible sum of an ascending subarray in `nums`.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is ascending if for all `i` where `l <= i < r`, `numsi  < numsi+1`. Note that a subarray of size `1` is ascending.


Example 1:
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.


Example 2:
Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.


Example 3:
Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.


Example 4:
Input: nums = [100,10,1]
Output: 100

Constraints:
`1 <= nums.length <= 100`
`1 <= nums[i] <= 100`",Easy,"public class Solution {
    public int MaxAscendingSum(int[] nums) {
        // Initialize variables to keep track of the maximum sum and the current sum
        int maxSum = 0;
        int currentSum = 0;
        
        // Iterate through the array
        for (int i = 0; i < nums.Length; i++) {
            // If it's the first element or the current element is greater than the previous one
            if (i == 0 || nums[i] > nums[i - 1]) {
                // Add the current element to the current sum
                currentSum += nums[i];
            } else {
                // Otherwise, compare the current sum with the max sum and update if necessary
                if (currentSum > maxSum) {
                    maxSum = currentSum;
                }
                // Reset the current sum to start a new subarray
                currentSum = nums[i];
            }
        }
        
        // Final comparison to ensure the last subarray is considered
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
        
        // Return the maximum sum found
        return maxSum;
    }
}"
Maximum Subarray Sum After One Operation,"You are given an integer array `nums`. You must perform exactly one operation where you can replace one element `nums[i]` with `nums[i] * nums[i]`. 
Return the maximum possible subarray sum after exactly one operation. The subarray must be non-empty.


Example 1:
Input: nums = [2,-1,-4,-3]
Output: 17
Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.


Example 2:
Input: nums = [1,-1,1,1,-1,-1,1]
Output: 4
Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.


Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`",Medium,"public class Solution {
    public int MaxSubarraySumAfterOperation(int[] nums) {
        if (nums == null || nums.Length == 0) {
            return 0;
        }

        int max_ending_here = nums[0];
        int max_ending_here_with_op = nums[0] * nums[0];
        int result = Math.Max(max_ending_here, max_ending_here_with_op);

        for (int i = 1; i < nums.Length; i++) {
            // Update max_ending_here without operation
            if (max_ending_here > 0) {
                max_ending_here += nums[i];
            } else {
                max_ending_here = nums[i];
            }

            // Update max_ending_here_with_op with operation
            int op_value = nums[i] * nums[i];
            if (max_ending_here_with_op > 0) {
                max_ending_here_with_op += nums[i];
            } else {
                max_ending_here_with_op = op_value;
            }

            // Consider the case where we perform the operation at the current index
            int new_op_value = max_ending_here + op_value;
            if (new_op_value > max_ending_here_with_op) {
                max_ending_here_with_op = new_op_value;
            }

            // Update the result with the maximum value found so far
            if (max_ending_here_with_op > result) {
                result = max_ending_here_with_op;
            }
        }

        return result;
    }
}"
Walls and Gates,"You are given an `m x n` grid `rooms` initialized with these three possible values.

`-1` A wall or an obstacle.

`0` A gate.

`INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with `INF`.


Example 1:
Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

Example 2:
Input: rooms = [[-1]]
Output: [[-1]]

Example 3:
Input: rooms = [[2147483647]]
Output: [[2147483647]]

Example 4:
Input: rooms = [[0]]
Output: [[0]]

Constraints:
`m == rooms.length`
`n == rooms[i].length`
`1 <= m, n <= 250`
`rooms[i][j]` is `-1`, `0`, or `231 - 1`.",Medium,"using System;
using System.Collections.Generic;

public class Solution {
    public void WallsAndGates(int[,] rooms) {
        if (rooms == null || rooms.GetLength(0) == 0 || rooms.GetLength(1) == 0) {
            return;
        }

        int m = rooms.GetLength(0);
        int n = rooms.GetLength(1);
        Queue<int[]> queue = new Queue<int[]>();

        // Step 1: Identify all gates and add them to the queue
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i, j] == 0) {
                    queue.Enqueue(new int[] { i, j });
                }
            }
        }

        // Step 2: Perform BFS from each gate
        while (queue.Count > 0) {
            int[] current = queue.Dequeue();
            int row = current[0];
            int col = current[1];

            // Check all four directions
            int[] rowDirections = { -1, 1, 0, 0 };
            int[] colDirections = { 0, 0, -1, 1 };

            for (int d = 0; d < 4; d++) {
                int newRow = row + rowDirections[d];
                int newCol = col + colDirections[d];

                // Check if the new position is within bounds and is an empty room
                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && rooms[newRow, newCol] == int.MaxValue) {
                    // Update the distance and add to the queue
                    rooms[newRow, newCol] = rooms[row, col] + 1;
                    queue.Enqueue(new int[] { newRow, newCol });
                }
            }
        }
    }
}"
Longest Common Subsequence,"Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, `""ace""` is a subsequence of `""abcde""`.

A common subsequence of two strings is a subsequence that is common to both strings.


Example 1:
Input: text1 = ""abcde"", text2 = ""ace"" 
Output: 3  
Explanation: The longest common subsequence is ""ace"" and its length is 3.


Example 2:
Input: text1 = ""abc"", text2 = ""abc""
Output: 3
Explanation: The longest common subsequence is ""abc"" and its length is 3.


Example 3:
Input: text1 = ""abc"", text2 = ""def""
Output: 0
Explanation: There is no such common subsequence, so the result is 0.


Constraints:
`1 <= text1.length, text2.length <= 1000`
`text1` and `text2` consist of only lowercase English characters.",Medium,"public class Solution {
    public int LongestCommonSubsequence(string text1, string text2) {
        int m = text1.Length;
        int n = text2.Length;
        
        // Create a 2D array to store lengths of longest common subsequence.
        int[,] dp = new int[m + 1, n + 1];
        
        // Build the dp array from bottom up
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i, j] = dp[i - 1, j - 1] + 1;
                } else {
                    dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                }
            }
        }
        
        // The length of the longest common subsequence is in the bottom-right cell
        return dp[m, n];
    }
}"
Satisfiability of Equality Equations,"Given an array equations of strings that represent relationships between variables, each string `equations[i]` has length `4` and takes one of two different forms: `""a==b""` or `""a!=b""`.  Here, `a` and `b` are lowercase letters (not necessarily different) that represent one-letter variable names.

Return `true` if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.


Example 1:
Input: [""a==b"",""b!=a""]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.


Example 2:
Input: [""b==a"",""a==b""]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.


Example 3:
Input: [""a==b"",""b==c"",""a==c""]
Output: true

Example 4:
Input: [""a==b"",""b!=c"",""c==a""]
Output: false

Example 5:
Input: [""c==c"",""b==d"",""x!=z""]
Output: true
Note:
`1 <= equations.length <= 500`
`equations[i].length == 4`
`equations[i][0]` and `equations[i][3]` are lowercase letters
`equations[i][1]` is either `'='` or `'!'`
`equations[i][2]` is `'='`",Medium,"public class Solution {
    public bool EquationsPossible(string[] equations) {
        // Step 1: Initialize Union-Find structure
        int[] parent = new int[26];
        for (int i = 0; i < 26; i++) {
            parent[i] = i;
        }

        // Helper function to find the root of a set
        int Find(int x) {
            while (parent[x] != x) {
                x = parent[x];
            }
            return x;
        }

        // Helper function to union two sets
        void Union(int x, int y) {
            int rootX = Find(x);
            int rootY = Find(y);
            if (rootX != rootY) {
                parent[rootX] = rootY;
            }
        }

        // Step 2: Process all ""=="" equations
        foreach (var eq in equations) {
            if (eq[1] == '=') {
                int var1 = eq[0] - 'a';
                int var2 = eq[3] - 'a';
                Union(var1, var2);
            }
        }

        // Step 3: Process all ""!="" equations
        foreach (var eq in equations) {
            if (eq[1] == '!') {
                int var1 = eq[0] - 'a';
                int var2 = eq[3] - 'a';
                if (Find(var1) == Find(var2)) {
                    return false; // Contradiction found
                }
            }
        }

        return true; // No contradictions found
    }
}"
Check Completeness of a Binary Tree,"Given the `root` of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.


Example 2:
Input: root = [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.


Constraints:
The number of nodes in the tree is in the range `[1, 100]`.

`1 <= Node.val <= 1000`",Medium,"public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x) { val = x; }
}

public class Solution {
    public bool IsCompleteTree(TreeNode root) {
        if (root == null) return true;

        // Initialize a queue for level-order traversal
        var queue = new Queue<TreeNode>();
        queue.Enqueue(root);

        // Flag to indicate if we have encountered a null child
        bool end = false;

        while (queue.Count > 0) {
            var node = queue.Dequeue();

            // Check the left child
            if (node.left != null) {
                if (end) return false; // If we've seen a null child before, the tree is not complete
                queue.Enqueue(node.left);
            } else {
                end = true; // Mark that we've encountered a null child
            }

            // Check the right child
            if (node.right != null) {
                if (end) return false; // If we've seen a null child before, the tree is not complete
                queue.Enqueue(node.right);
            } else {
                end = true; // Mark that we've encountered a null child
            }
        }

        return true;
    }
}"
Maximum Number of Non-Overlapping Subarrays With Sum Equals Target,"Given an array `nums` and an integer `target`.

Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to `target`.


Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).


Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.

([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.


Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

Constraints:
`1 <= nums.length <= 10^5`
`-10^4 <= nums[i] <= 10^4`
`0 <= target <= 10^6`",Medium,"using System;
using System.Collections.Generic;

public class Solution
{
    public int MaxNonOverlapping(int[] nums, int target)
    {
        int count = 0;
        int currentSum = 0;
        HashSet<int> seenSums = new HashSet<int>();
        
        // Initialize the set with 0 to handle subarrays starting from index 0
        seenSums.Add(0);
        
        foreach (int num in nums)
        {
            currentSum += num;
            
            // Check if there is a subarray ending at the current index with sum equal to target
            if (seenSums.Contains(currentSum - target))
            {
                count++;
                // Reset currentSum and clear seenSums to ensure non-overlapping
                currentSum = 0;
                seenSums.Clear();
                // Re-add 0 to the set for the next potential subarray
                seenSums.Add(0);
            }
            else
            {
                // Add the current prefix sum to the set
                seenSums.Add(currentSum);
            }
        }
        
        return count;
    }
    
    public static void Main(string[] args)
    {
        Solution solution = new Solution();
        
        Console.WriteLine(solution.MaxNonOverlapping(new int[] {1,1,1,1,1}, 2)); // Output: 2
        Console.WriteLine(solution.MaxNonOverlapping(new int[] {-1,3,5,1,4,2,-9}, 6)); // Output: 2
        Console.WriteLine(solution.MaxNonOverlapping(new int[] {-2,6,6,3,5,4,1,2,8}, 10)); // Output: 3
        Console.WriteLine(solution.MaxNonOverlapping(new int[] {0,0,0}, 0)); // Output: 3
    }
}"
Find Nearest Right Node in Binary Tree,"Given the `root` of a binary tree and a node `u` in the tree, return the nearest node on the same level that is to the right of `u`, or return `null` if `u` is the rightmost node in its level.


Example 1:
Input: root = [1,2,3,null,4,5,6], u = 4
Output: 5
Explanation: The nearest node on the same level to the right of node 4 is node 5.


Example 2:
Input: root = [3,null,4,2], u = 2
Output: null
Explanation: There are no nodes to the right of 2.


Example 3:
Input: root = [1], u = 1
Output: null

Example 4:
Input: root = [3,4,2,null,null,null,1], u = 4
Output: 2

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 105`
All values in the tree are distinct.

`u` is a node in the binary tree rooted at `root`.",Medium,"using System.Collections.Generic;

public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x) { val = x; }
}

public class Solution {
    public TreeNode FindNearestRightNode(TreeNode root, TreeNode u) {
        if (root == null) return null;

        // Initialize a queue for level-order traversal
        Queue<TreeNode> queue = new Queue<TreeNode>();
        queue.Enqueue(root);

        while (queue.Count > 0) {
            // Get the number of nodes at the current level
            int levelSize = queue.Count;
            bool foundU = false;

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.Dequeue();

                // Check if the current node is the target node 'u'
                if (foundU) {
                    // Return the next node as it is the nearest right node
                    return currentNode;
                }

                // If the current node is 'u', set foundU to true
                if (currentNode == u) {
                    foundU = true;
                } else {
                    // Otherwise, enqueue the children of the current node
                    if (currentNode.left != null) {
                        queue.Enqueue(currentNode.left);
                    }
                    if (currentNode.right != null) {
                        queue.Enqueue(currentNode.right);
                    }
                }
            }

            // If 'u' was found and there were no more nodes in the level, return null
            if (foundU) {
                return null;
            }
        }

        // If 'u' is not found in the tree, return null
        return null;
    }
}"
Put Boxes Into the Warehouse II,"You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labeled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.

Boxes are put into the warehouse by the following rules:
Boxes cannot be stacked.

You can rearrange the insertion order of the boxes.

Boxes can be pushed into the warehouse from either side (left or right)
If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.

Return the maximum number of boxes you can put into the warehouse.


Example 1:
Input: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]
Output: 4
Explanation:
We can store the boxes in the following order:
1- Put the yellow box in room 2 from either the left or right side.

2- Put the orange box in room 3 from the right side.

3- Put the green box in room 1 from the left side.

4- Put the red box in room 0 from the left side.

Notice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.


Example 2:
Input: boxes = [3,5,5,2], warehouse = [2,1,3,4,5]
Output: 3
Explanation:
It's not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.

Other valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes.


Example 3:
Input: boxes = [1,2,3], warehouse = [1,2,3,4]
Output: 3

Example 4:
Input: boxes = [4,5,6], warehouse = [3,3,3,3,3]
Output: 0

Constraints:
`n == warehouse.length`
`1 <= boxes.length, warehouse.length <= 105`
`1 <= boxes[i], warehouse[i] <= 109`",Medium,"public class Solution {
    public int MaxBoxesInWarehouse(int[] boxes, int[] warehouse) {
        // Step 1: Sort the boxes
        Array.Sort(boxes);
        
        // Step 2: Preprocess the warehouse heights
        int n = warehouse.Length;
        int[] left_max = new int[n];
        int[] right_max = new int[n];
        
        left_max[0] = warehouse[0];
        for (int i = 1; i < n; i++) {
            left_max[i] = Math.Max(left_max[i - 1], warehouse[i]);
        }
        
        right_max[n - 1] = warehouse[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            right_max[i] = Math.Max(right_max[i + 1], warehouse[i]);
        }
        
        // Step 3: Two-pointer technique
        int left = 0;
        int right = n - 1;
        int boxIndex = 0;
        int count = 0;
        
        while (boxIndex < boxes.Length && left <= right) {
            int box = boxes[boxIndex];
            
            if (left_max[left] >= box && right_max[right] >= box) {
                // Choose the position that allows more boxes to be placed
                if (left_max[left] >= right_max[right]) {
                    left++;
                } else {
                    right--;
                }
                count++;
            } else if (left_max[left] >= box) {
                left++;
            } else if (right_max[right] >= box) {
                right--;
            } else {
                // Box cannot be placed in either position
                boxIndex++;
            }
        }
        
        return count;
    }
}"
Minimum Swaps to Group All 1's Together,"Given a binary array `data`, return the minimum number of swaps required to group all `1`’s present in the array together in any place in the array.


Example 1:
Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.

[0,1,1,1,0] using 2 swaps.

[0,0,1,1,1] using 1 swap.

The minimum is 1.


Example 2:
Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


Example 3:
Input: data = [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: 
One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].


Example 4:
Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
Output: 8

Constraints:
`1 <= data.length <= 105`
`data[i]` is `0` or `1`.",Medium,"public class Solution {
    public int MinSwaps(int[] data) {
        // Step 1: Count the total number of 1s in the array
        int totalOnes = 0;
        for (int i = 0; i < data.Length; i++) {
            if (data[i] == 1) {
                totalOnes++;
            }
        }

        // Edge case: If there are no 1s or only one 1, no swaps are needed
        if (totalOnes <= 1) {
            return 0;
        }

        // Step 2: Initialize variables for the sliding window
        int maxOnesInWindow = 0;
        int currentOnesInWindow = 0;
        int left = 0;

        // Step 3: Use sliding window to find the maximum number of 1s in any window of size totalOnes
        for (int right = 0; right < data.Length; right++) {
            if (data[right] == 1) {
                currentOnesInWindow++;
            }

            // If the window size exceeds totalOnes, shrink the window from the left
            if (right - left + 1 > totalOnes) {
                if (data[left] == 1) {
                    currentOnesInWindow--;
                }
                left++;
            }

            // Update the maximum number of 1s found in any window
            maxOnesInWindow = Math.Max(maxOnesInWindow, currentOnesInWindow);
        }

        // Step 4: Calculate the minimum number of swaps required
        return totalOnes - maxOnesInWindow;
    }
}"
Minimum Remove to Make Valid Parentheses,"Given a string s of `'('` , `')'` and lowercase English characters. 
Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or
It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
It can be written as `(A)`, where `A` is a valid string.


Example 1:
Input: s = ""lee(t(c)o)de)""
Output: ""lee(t(c)o)de""
Explanation: ""lee(t(co)de)"" , ""lee(t(c)ode)"" would also be accepted.


Example 2:
Input: s = ""a)b(c)d""
Output: ""ab(c)d""

Example 3:
Input: s = ""))((""
Output: """"
Explanation: An empty string is also valid.


Example 4:
Input: s = ""(a(b(c)d)""
Output: ""a(b(c)d)""

Constraints:
`1 <= s.length <= 10^5`
`s[i]` is one of  `'('` , `')'` and lowercase English letters`.`",Medium,"public class Solution {
    public string MinRemoveToMakeValid(string s) {
        // Convert the string to a character array for easier manipulation
        char[] chars = s.ToCharArray();
        
        // First pass: left to right
        int balance = 0;
        for (int i = 0; i < chars.Length; i++) {
            if (chars[i] == '(') {
                balance++;
            } else if (chars[i] == ')') {
                if (balance > 0) {
                    balance--;
                } else {
                    // Mark extra ')' as invalid
                    chars[i] = '*';
                }
            }
        }
        
        // Second pass: right to left
        balance = 0;
        for (int i = chars.Length - 1; i >= 0; i--) {
            if (chars[i] == ')') {
                balance++;
            } else if (chars[i] == '(') {
                if (balance > 0) {
                    balance--;
                } else {
                    // Mark extra '(' as invalid
                    chars[i] = '*';
                }
            }
        }
        
        // Construct the result string excluding marked characters
        StringBuilder result = new StringBuilder();
        foreach (char c in chars) {
            if (c != '*') {
                result.Append(c);
            }
        }
        
        return result.ToString();
    }
}"
Trapping Rain Water,"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.


Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.


Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
`n == height.length`
`0 <= n <= 3 * 104`
`0 <= height[i] <= 105`",Hard,"public class Solution {
    public int Trap(int[] height) {
        if (height == null || height.Length == 0) {
            return 0;
        }

        int left = 0;
        int right = height.Length - 1;
        int maxLeft = 0;
        int maxRight = 0;
        int waterTrapped = 0;

        while (left < right) {
            if (height[left] <= height[right]) {
                if (height[left] >= maxLeft) {
                    maxLeft = height[left];
                } else {
                    waterTrapped += maxLeft - height[left];
                }
                left++;
            } else {
                if (height[right] >= maxRight) {
                    maxRight = height[right];
                } else {
                    waterTrapped += maxRight - height[right];
                }
                right--;
            }
        }

        return waterTrapped;
    }
}"
Minimum Cost to Make at Least One Valid Path in a Grid,"Given a m x n `grid`. Each cell of the `grid` has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:
1 which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)
2 which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)
3 which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)
4 which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)
Notice that there could be some invalid signs on the cells of the `grid` which points outside the `grid`.

You will initially start at the upper left cell `(0,0)`. A valid path in the grid is a path which starts from the upper left cell `(0,0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.


Example 1:
Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).

The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.


Example 2:
Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).


Example 3:
Input: grid = [[1,2],[4,3]]
Output: 1

Example 4:
Input: grid = [[2,2,2],[2,2,2]]
Output: 3

Example 5:
Input: grid = [[4]]
Output: 0

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`",Hard,"using System;
using System.Collections.Generic;

public class Solution
{
    public int MinCost(int[][] grid)
    {
        int m = grid.Length;
        int n = grid[0].Length;
        
        // Directions: right, left, down, up
        int[][] directions = new int[][]
        {
            new int[] { 0, 1 },
            new int[] { 0, -1 },
            new int[] { 1, 0 },
            new int[] { -1, 0 }
        };
        
        // Distance array initialized to infinity
        int[,] dist = new int[m, n];
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                dist[i, j] = int.MaxValue;
            }
        }
        dist[0, 0] = 0;
        
        // Priority queue to store cells with their distances
        var pq = new PriorityQueue<int[], int>();
        pq.Enqueue(new int[] { 0, 0 }, 0);
        
        while (pq.Count > 0)
        {
            var current = pq.Dequeue();
            int x = current[0];
            int y = current[1];
            
            // Explore all four directions
            for (int d = 0; d < 4; d++)
            {
                int newX = x + directions[d][0];
                int newY = y + directions[d][1];
                
                // Check if the new position is within bounds
                if (newX >= 0 && newX < m && newY >= 0 && newY < n)
                {
                    // Calculate the cost to move to the new cell
                    int cost = (grid[x][y] == d + 1) ? 0 : 1;
                    
                    // Update the distance if a shorter path is found
                    if (dist[x, y] + cost < dist[newX, newY])
                    {
                        dist[newX, newY] = dist[x, y] + cost;
                        pq.Enqueue(new int[] { newX, newY }, dist[newX, newY]);
                    }
                }
            }
        }
        
        // Return the minimum cost to reach the bottom-right cell
        return dist[m - 1, n - 1];
    }
    
    // Custom priority queue implementation
    public class PriorityQueue<TItem, TPriority> where TPriority : IComparable<TPriority>
    {
        private List<KeyValuePair<TItem, TPriority>> _items = new List<KeyValuePair<TItem, TPriority>>();
        
        public void Enqueue(TItem item, TPriority priority)
        {
            _items.Add(new KeyValuePair<TItem, TPriority>(item, priority));
            _items.Sort((a, b) => a.Value.CompareTo(b.Value));
        }
        
        public TItem Dequeue()
        {
            if (_items.Count == 0)
            {
                throw new InvalidOperationException(""Queue is empty"");
            }
            
            KeyValuePair<TItem, TPriority> item = _items[0];
            _items.RemoveAt(0);
            return item.Key;
        }
        
        public int Count => _items.Count;
    }
}"
Pizza With 3n Slices,"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:
You will pick any pizza slice.

Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.

Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.


Example 1:
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.


Example 2:
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.

Example 3:
Input: slices = [4,1,2,5,8,3,1,9,7]
Output: 21

Example 4:
Input: slices = [3,1,2]
Output: 3

Constraints:
`1 <= slices.length <= 500`
`slices.length % 3 == 0`
`1 <= slices[i] <= 1000`",Hard,"public class Solution {
    public int maxSizeSlices(int[] slices) {
        int n = slices.Length;
        if (n == 1) return slices[0];
        
        // Helper function to solve the problem for a linear array
        int MaxSizeSlicesLinear(int[] arr, int k) {
            int len = arr.Length;
            int[][] dp = new int[len + 1][k + 1];
            
            for (int i = 1; i <= len; i++) {
                for (int j = 1; j <= k; j++) {
                    if (i == 1) {
                        dp[i][j] = arr[i - 1];
                    } else {
                        dp[i][j] = Math.Max(dp[i - 1][j], dp[i - 2][j - 1] + arr[i - 1]);
                    }
                }
            }
            
            return dp[len][k];
        }
        
        // Solve for two cases: excluding the first and excluding the last slice
        int case1 = MaxSizeSlicesLinear(slices, n / 3);
        int case2 = MaxSizeSlicesLinear(new int[n - 1], n / 3);
        
        return Math.Max(case1, case2);
    }
}"
Number of Ways to Wear Different Hats to Each Other,"There are `n` people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers `hats`, where `hats[i]` is a list of all hats preferred by the i-th` person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.


Example 2:
Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats
(3,5), (5,3), (1,3) and (1,5)

Example 3:
Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.

Number of Permutations of (1,2,3,4) = 24.


Example 4:
Input: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
Output: 111

Constraints:
`n == hats.length`
`1 <= n <= 10`
`1 <= hats[i].length <= 40`
`1 <= hats[i][j] <= 40`
`hats[i]` contains a list of unique integers.",Hard,"using System;
using System.Collections.Generic;

public class Solution {
    public int NumberWays(List<List<int>> hats) {
        const int MOD = 1_000_000_007;
        int n = hats.Count;
        
        // Map each hat to the list of people who prefer that hat
        Dictionary<int, List<int>> personByHat = new Dictionary<int, List<int>>();
        for (int i = 0; i < n; i++) {
            foreach (int hat in hats[i]) {
                if (!personByHat.ContainsKey(hat)) {
                    personByHat[hat] = new List<int>();
                }
                personByHat[hat].Add(i);
            }
        }
        
        // DP array to store the number of ways to assign hats
        int[] dp = new int[1 << n];
        dp[0] = 1; // Base case: one way to assign hats to zero people
        
        // Iterate over each hat
        for (int hat = 1; hat <= 40; hat++) {
            // Iterate over all possible subsets of people
            for (int mask = (1 << n) - 1; mask >= 0; mask--) {
                if (personByHat.ContainsKey(hat)) {
                    foreach (int person in personByHat[hat]) {
                        if ((mask & (1 << person)) == 0) { // If person is not yet assigned a hat
                            dp[mask | (1 << person)] = (dp[mask | (1 << person)] + dp[mask]) % MOD;
                        }
                    }
                }
            }
        }
        
        // The result is the number of ways to assign hats to all n people
        return dp[(1 << n) - 1];
    }
}"
Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an `m * n` matrix, `mat`, and an integer `k`, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.


Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.  

Example 2:
Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17

Example 3:
Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  

Example 4:
Input: mat = [[1,1,10],[2,2,9]], k = 7
Output: 12

Constraints:
`m == mat.length`
`n == mat.length[i]`
`1 <= m, n <= 40`
`1 <= k <= min(200, n ^ m)`
`1 <= mat[i][j] <= 5000`
`mat[i]` is a non decreasing array.",Hard,"using System;
using System.Collections.Generic;

public class Solution
{
    public int KthSmallest(int[][] mat, int k)
    {
        // Initialize the priority queue with the first row elements
        PriorityQueue<int> pq = new PriorityQueue<int>();
        foreach (int num in mat[0])
        {
            pq.Enqueue(num);
        }

        // Process each row starting from the second row
        for (int i = 1; i < mat.Length; i++)
        {
            PriorityQueue<int> newPq = new PriorityQueue<int>();
            while (pq.Count > 0 && newPq.Count < k)
            {
                int currentSum = pq.Dequeue();
                foreach (int num in mat[i])
                {
                    int newSum = currentSum + num;
                    if (newPq.Count < k)
                    {
                        newPq.Enqueue(newSum);
                    }
                    else if (newSum < newPq.Peek())
                    {
                        newPq.Dequeue();
                        newPq.Enqueue(newSum);
                    }
                }
            }
            pq = newPq;
        }

        // The k-th smallest sum is at the top of the priority queue
        return pq.Dequeue();
    }

    // Custom PriorityQueue class to maintain the smallest k elements
    private class PriorityQueue<T> where T : IComparable<T>
    {
        private List<T> items = new List<T>();

        public void Enqueue(T item)
        {
            items.Add(item);
            items.Sort();
        }

        public T Dequeue()
        {
            if (items.Count == 0)
            {
                throw new InvalidOperationException(""Priority queue is empty."");
            }
            T item = items[0];
            items.RemoveAt(0);
            return item;
        }

        public int Count => items.Count;

        public T Peek()
        {
            if (items.Count == 0)
            {
                throw new InvalidOperationException(""Priority queue is empty."");
            }
            return items[0];
        }
    }
}"
Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:
Type 1: Can be traversed by Alice only.

Type 2: Can be traversed by Bob only.

Type 3: Can by traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.


Example 1:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.


Example 2:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.


Example 3:
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.


Constraints:
`1 <= n <= 10^5`
`1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
`edges[i].length == 3`
`1 <= edges[i][0] <= 3`
`1 <= edges[i][1] < edges[i][2] <= n`
All tuples `(typei, ui, vi)` are distinct.",Hard,"using System;

public class Solution {
    public int MaxNumEdgesToRemove(int n, int[][] edges) {
        // Initialize Union-Find structures for Alice and Bob
        UnionFind aliceUF = new UnionFind(n);
        UnionFind bobUF = new UnionFind(n);

        int redundantEdges = 0;

        // Process Type 3 edges first
        foreach (var edge in edges) {
            if (edge[0] == 3) {
                if (!aliceUF.Union(edge[1], edge[2])) {
                    redundantEdges++;
                }
                bobUF.Union(edge[1], edge[2]);
            }
        }

        // Process Type 1 edges for Alice
        foreach (var edge in edges) {
            if (edge[0] == 1) {
                if (!aliceUF.Union(edge[1], edge[2])) {
                    redundantEdges++;
                }
            }
        }

        // Process Type 2 edges for Bob
        foreach (var edge in edges) {
            if (edge[0] == 2) {
                if (!bobUF.Union(edge[1], edge[2])) {
                    redundantEdges++;
                }
            }
        }

        // Check if both Alice and Bob can traverse all nodes
        if (aliceUF.GetConnectedComponents() != 1 || bobUF.GetConnectedComponents() != 1) {
            return -1;
        }

        return redundantEdges;
    }

    private class UnionFind {
        private int[] parent;
        private int[] rank;
        private int components;

        public UnionFind(int n) {
            parent = new int[n + 1];
            rank = new int[n + 1];
            components = n;
            for (int i = 1; i <= n; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }

        public bool Union(int u, int v) {
            int rootU = Find(u);
            int rootV = Find(v);

            if (rootU == rootV) {
                return false; // Already connected
            }

            if (rank[rootU] > rank[rootV]) {
                parent[rootV] = rootU;
            } else if (rank[rootU] < rank[rootV]) {
                parent[rootU] = rootV;
            } else {
                parent[rootV] = rootU;
                rank[rootU]++;
            }

            components--;
            return true;
        }

        public int Find(int u) {
            if (parent[u] != u) {
                parent[u] = Find(parent[u]); // Path compression
            }
            return parent[u];
        }

        public int GetConnectedComponents() {
            return components;
        }
    }
}"
Minimum Operations to Make a Subsequence,"You are given an array `target` that consists of distinct integers and another integer array `arr` that can have duplicates.

In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make `target` a subsequence of `arr`.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.


Example 1:
Input: target = [5,1,3], `arr` = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`.


Example 2:
Input: target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1]
Output: 3

Constraints:
`1 <= target.length, arr.length <= 105`
`1 <= target[i], arr[i] <= 109`
`target` contains no duplicates.",Hard,"using System;
using System.Collections.Generic;

public class Solution {
    public int MinOperations(int[] target, int[] arr) {
        // Step 1: Map target values to their indices
        Dictionary<int, int> targetIndexMap = new Dictionary<int, int>();
        for (int i = 0; i < target.Length; i++) {
            targetIndexMap[target[i]] = i;
        }

        // Step 2: Transform arr into a sequence of indices
        List<int> transformedArr = new List<int>();
        foreach (int num in arr) {
            if (targetIndexMap.ContainsKey(num)) {
                transformedArr.Add(targetIndexMap[num]);
            }
        }

        // Step 3: Find the LIS of the transformed sequence
        int lisLength = LengthOfLIS(transformedArr);

        // Step 4: Calculate the minimum number of insertions
        return target.Length - lisLength;
    }

    private int LengthOfLIS(List<int> nums) {
        if (nums.Count == 0) return 0;

        // This list will store the smallest tail of all increasing subsequences
        // with different lengths.
        List<int> lis = new List<int>();
        lis.Add(nums[0]);

        for (int i = 1; i < nums.Count; i++) {
            int num = nums[i];
            if (num > lis[lis.Count - 1]) {
                // If num is greater than the last element in lis, extend the lis
                lis.Add(num);
            } else {
                // Otherwise, find the first element in lis which is greater than or equal to num
                // and replace it with num. This helps in maintaining the smallest possible tail.
                int left = 0, right = lis.Count - 1;
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    if (lis[mid] < num) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                lis[left] = num;
            }
        }

        return lis.Count;
    }
}"
Edit Distance,"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.

You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character

Example 1:
Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

Constraints:
`0 <= word1.length, word2.length <= 500`
`word1` and `word2` consist of lowercase English letters.",Hard,"public class Solution {
    public int MinDistance(string word1, string word2) {
        int m = word1.Length;
        int n = word2.Length;
        
        // Create a 2D array to store the minimum operations
        int[,] dp = new int[m + 1, n + 1];
        
        // Initialize the base cases
        for (int i = 0; i <= m; i++) {
            dp[i, 0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0, j] = j;
        }
        
        // Fill the DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i, j] = dp[i - 1, j - 1];
                } else {
                    int insert = dp[i, j - 1] + 1;
                    int delete = dp[i - 1, j] + 1;
                    int replace = dp[i - 1, j - 1] + 1;
                    
                    dp[i, j] = Math.Min(insert, Math.Min(delete, replace));
                }
            }
        }
        
        // The result is in the bottom-right corner of the DP table
        return dp[m, n];
    }
}"
Maximum Profit in Job Scheduling,"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.


Example 1:
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.


Example 2:
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.


Example 3:
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6

Constraints:
`1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
`1 <= startTime[i] < endTime[i] <= 109`
`1 <= profit[i] <= 104`",Hard,"using System;

public class Solution {
    public int JobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n = startTime.Length;
        
        // Create an array of jobs where each job is represented as (start, end, profit)
        Job[] jobs = new Job[n];
        for (int i = 0; i < n; i++) {
            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);
        }
        
        // Sort jobs by their end times
        Array.Sort(jobs, (a, b) => a.end.CompareTo(b.end));
        
        // Initialize dp array
        int[] dp = new int[n + 1];
        
        // Fill dp array
        for (int i = 1; i <= n; i++) {
            // Option 1: Do not take the current job
            dp[i] = dp[i - 1];
            
            // Option 2: Take the current job
            // Find the last job that doesn't overlap with the current job
            int lastNonOverlapIndex = FindLastNonOverlapJob(jobs, i - 1);
            if (lastNonOverlapIndex != -1) {
                dp[i] = Math.Max(dp[i], dp[lastNonOverlapIndex + 1] + jobs[i - 1].profit);
            } else {
                dp[i] = Math.Max(dp[i], jobs[i - 1].profit);
            }
        }
        
        return dp[n];
    }
    
    private int FindLastNonOverlapJob(Job[] jobs, int index) {
        int low = 0;
        int high = index - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (jobs[mid].end <= jobs[index].start) {
                if (mid + 1 < index && jobs[mid + 1].end <= jobs[index].start) {
                    low = mid + 1;
                } else {
                    return mid;
                }
            } else {
                high = mid - 1;
            }
        }
        
        return -1;
    }
    
    private class Job {
        public int start;
        public int end;
        public int profit;
        
        public Job(int start, int end, int profit) {
            this.start = start;
            this.end = end;
            this.profit = profit;
        }
    }
}"
Cherry Pickup II,"Given a `rows x cols` matrix `grid` representing a field of cherries. Each cell in `grid` represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:
From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).

When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).

When both robots stay on the same cell, only one of them takes the cherries.

Both robots cannot move outside of the grid at any moment.

Both robots should reach the bottom row in the `grid`.


Example 1:
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.

Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.

Total of cherries: 12 + 12 = 24.


Example 2:
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.

Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.

Total of cherries: 17 + 11 = 28.


Example 3:
Input: grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
Output: 22

Example 4:
Input: grid = [[1,1],[1,1]]
Output: 4

Constraints:
`rows == grid.length`
`cols == grid[i].length`
`2 <= rows, cols <= 70`
`0 <= grid[i][j] <= 100 `",Hard,"using System;
using System.Collections.Generic;

public class Solution
{
    public int CherryPickup(int[][] grid)
    {
        int rows = grid.Length;
        int cols = grid[0].Length;
        Dictionary<(int, int, int), int> memo = new Dictionary<(int, int, int), int>();

        return CollectCherries(grid, memo, 0, 0, cols - 1);
    }

    private int CollectCherries(int[][] grid, Dictionary<(int, int, int), int> memo, int row, int pos1, int pos2)
    {
        if (row == grid.Length)
        {
            return 0;
        }

        if (memo.ContainsKey((row, pos1, pos2)))
        {
            return memo[(row, pos1, pos2)];
        }

        int cherries = 0;
        cherries += grid[row][pos1];
        if (pos1 != pos2)
        {
            cherries += grid[row][pos2];
        }

        int maxCherries = 0;
        for (int d1 = -1; d1 <= 1; d1++)
        {
            for (int d2 = -1; d2 <= 1; d2++)
            {
                int newPos1 = pos1 + d1;
                int newPos2 = pos2 + d2;

                if (newPos1 >= 0 && newPos1 < grid[0].Length && newPos2 >= 0 && newPos2 < grid[0].Length)
                {
                    maxCherries = Math.Max(maxCherries, CollectCherries(grid, memo, row + 1, newPos1, newPos2));
                }
            }
        }

        int result = cherries + maxCherries;
        memo[(row, pos1, pos2)] = result;
        return result;
    }
}"
