title,description,difficulty,solution
Relative Ranks,"You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:
The `1st` place athlete's rank is `""Gold Medal""`.

The `2nd` place athlete's rank is `""Silver Medal""`.

The `3rd` place athlete's rank is `""Bronze Medal""`.

For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `""x""`).

Return an array `answer` of size `n` where `answer[i]` is the rank of the `ith` athlete.


Example 1:
Input: score = [5,4,3,2,1]
Output: [""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].


Example 2:
Input: score = [10,3,8,9,4]
Output: [""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].


Constraints:
`n == score.length`
`1 <= n <= 104`
`0 <= score[i] <= 106`
All the values in `score` are unique.",Easy,"function findRelativeRanks(score: number[]): string[] {
    // Step 1: Custom Sort - Implementing Bubble Sort for simplicity
    const n = score.length;
    const sortedScores = [...score]; // Copy the original array to sort

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (sortedScores[j] < sortedScores[j + 1]) {
                // Swap if the current element is less than the next element
                const temp = sortedScores[j];
                sortedScores[j] = sortedScores[j + 1];
                sortedScores[j + 1] = temp;
            }
        }
    }

    // Step 2: Assign Ranks
    const rankMap: { [key: number]: string } = {};
    const medals = [""Gold Medal"", ""Silver Medal"", ""Bronze Medal""];

    for (let i = 0; i < n; i++) {
        if (i < 3) {
            rankMap[sortedScores[i]] = medals[i];
        } else {
            rankMap[sortedScores[i]] = (i + 1).toString();
        }
    }

    // Step 3: Generate Result
    const result: string[] = [];
    for (let i = 0; i < n; i++) {
        result.push(rankMap[score[i]]);
    }

    return result;
}

// Example usage:
console.log(findRelativeRanks([5, 4, 3, 2, 1])); // Output: [""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
console.log(findRelativeRanks([10, 3, 8, 9, 4])); // Output: [""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]"
Truncate Sentence,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).

For example, `""Hello World""`, `""HELLO""`, and `""hello world hello world""` are all sentences.

You are given a sentence `s`​​​​​​ and an integer `k`​​​​​​. You want to truncate `s`​​​​​​ such that it contains only the first `k`​​​​​​ words. Return `s`​​​​​​ after truncating it.


Example 1:
Input: s = ""Hello how are you Contestant"", k = 4
Output: ""Hello how are you""
Explanation:
The words in s are [""Hello"", ""how"" ""are"", ""you"", ""Contestant""].

The first 4 words are [""Hello"", ""how"", ""are"", ""you""].

Hence, you should return ""Hello how are you"".


Example 2:
Input: s = ""What is the solution to this problem"", k = 4
Output: ""What is the solution""
Explanation:
The words in s are [""What"", ""is"" ""the"", ""solution"", ""to"", ""this"", ""problem""].

The first 4 words are [""What"", ""is"", ""the"", ""solution""].

Hence, you should return ""What is the solution"".


Example 3:
Input: s = ""chopper is not a tanuki"", k = 5
Output: ""chopper is not a tanuki""

Constraints:
`1 <= s.length <= 500`
`k` is in the range `[1, the number of words in s]`.

`s` consist of only lowercase and uppercase English letters and spaces.

The words in `s` are separated by a single space.

There are no leading or trailing spaces.",Easy,"function truncateSentence(s: string, k: number): string {
    let result = '';
    let wordCount = 0;
    let i = 0;

    while (i < s.length) {
        if (s[i] === ' ') {
            wordCount++;
            if (wordCount === k) {
                break;
            }
        }
        if (wordCount < k) {
            result += s[i];
        }
        i++;
    }

    return result;
}

// Example usage:
console.log(truncateSentence(""Hello how are you Contestant"", 4)); // Output: ""Hello how are you""
console.log(truncateSentence(""What is the solution to this problem"", 4)); // Output: ""What is the solution""
console.log(truncateSentence(""chopper is not a tanuki"", 5)); // Output: ""chopper is not a tanuki"""
Perform String Shifts,"You are given a string `s` containing lowercase English letters, and a matrix `shift`, where `shift[i] = [direction, amount]`:
`direction` can be `0` (for left shift) or `1` (for right shift). 
`amount` is the amount by which string `s` is to be shifted.

A left shift by 1 means remove the first character of `s` and append it to the end.

Similarly, a right shift by 1 means remove the last character of `s` and add it to the beginning.

Return the final string after all operations.


Example 1:
Input: s = ""abc"", shift = [[0,1],[1,2]]
Output: ""cab""
Explanation: 
[0,1] means shift to left by 1. ""abc"" -> ""bca""
[1,2] means shift to right by 2. ""bca"" -> ""cab""

Example 2:
Input: s = ""abcdefg"", shift = [[1,1],[1,1],[0,2],[1,3]]
Output: ""efgabcd""
Explanation:  
[1,1] means shift to right by 1. ""abcdefg"" -> ""gabcdef""
[1,1] means shift to right by 1. ""gabcdef"" -> ""fgabcde""
[0,2] means shift to left by 2. ""fgabcde"" -> ""abcdefg""
[1,3] means shift to right by 3. ""abcdefg"" -> ""efgabcd""

Constraints:
`1 <= s.length <= 100`
`s` only contains lower case English letters.

`1 <= shift.length <= 100`
`shift[i].length == 2`
`0 <= shift[i][0] <= 1`
`0 <= shift[i][1] <= 100`",Easy,"function stringShift(s: string, shift: number[][]): string {
    const n = s.length;
    
    // Calculate net shift
    let netShift = 0;
    for (const [direction, amount] of shift) {
        if (direction === 0) {
            netShift -= amount; // Left shift
        } else {
            netShift += amount; // Right shift
        }
    }
    
    // Normalize net shift
    netShift = ((netShift % n) + n) % n; // Ensure non-negative result
    
    // Apply shift
    if (netShift === 0) {
        return s; // No shift needed
    }
    
    // Perform the shift
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        const newIndex = (i + netShift) % n;
        result[newIndex] = s[i];
    }
    
    return result.join('');
}

// Example usage:
console.log(stringShift(""abc"", [[0,1],[1,2]])); // Output: ""cab""
console.log(stringShift(""abcdefg"", [[1,1],[1,1],[0,2],[1,3]])); // Output: ""efgabcd"""
Invert Binary Tree,"Given the `root` of a binary tree, invert the tree, and return its root.


Example 1:
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

Example 2:
Input: root = [2,1,3]
Output: [2,3,1]

Example 3:
Input: root = []
Output: []

Constraints:
The number of nodes in the tree is in the range `[0, 100]`.

`-100 <= Node.val <= 100`",Easy,"// Definition for a binary tree node.
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;

    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.left = (left===undefined ? null : left);
        this.right = (right===undefined ? null : right);
    }
}

function invertTree(root: TreeNode | null): TreeNode | null {
    // Base case: if the root is null, return null
    if (root === null) {
        return null;
    }

    // Swap the left and right children
    const temp = root.left;
    root.left = root.right;
    root.right = temp;

    // Recursively invert the left subtree
    invertTree(root.left);

    // Recursively invert the right subtree
    invertTree(root.right);

    // Return the root of the inverted tree
    return root;
}

// Example usage:
// Constructing the tree for example 1: [4,2,7,1,3,6,9]
const root1 = new TreeNode(4);
root1.left = new TreeNode(2);
root1.right = new TreeNode(7);
root1.left.left = new TreeNode(1);
root1.left.right = new TreeNode(3);
root1.right.left = new TreeNode(6);
root1.right.right = new TreeNode(9);

console.log(invertTree(root1)); // Output: [4,7,2,9,6,3,1]

// Constructing the tree for example 2: [2,1,3]
const root2 = new TreeNode(2);
root2.left = new TreeNode(1);
root2.right = new TreeNode(3);

console.log(invertTree(root2)); // Output: [2,3,1]

// Example 3: []
const root3: TreeNode | null = null;

console.log(invertTree(root3)); // Output: []"
Merge Strings Alternately,"You are given two strings `word1` and `word2`. Merge the strings by adding letters in alternating order, starting with `word1`. If a string is longer than the other, append the additional letters onto the end of the merged string.

Return the merged string.


Example 1:
Input: word1 = ""abc"", word2 = ""pqr""
Output: ""apbqcr""
Explanation: The merged string will be merged as so:
word1:  a   b   c
word2:    p   q   r
merged: a p b q c r

Example 2:
Input: word1 = ""ab"", word2 = ""pqrs""
Output: ""apbqrs""
Explanation: Notice that as word2 is longer, ""rs"" is appended to the end.

word1:  a   b 
word2:    p   q   r   s
merged: a p b q   r   s

Example 3:
Input: word1 = ""abcd"", word2 = ""pq""
Output: ""apbqcd""
Explanation: Notice that as word1 is longer, ""cd"" is appended to the end.

word1:  a   b   c   d
word2:    p   q 
merged: a p b q c   d

Constraints:
`1 <= word1.length, word2.length <= 100`
`word1` and `word2` consist of lowercase English letters.",Easy,"function mergeAlternately(word1: string, word2: string): string {
    const merged: string[] = [];
    const len1 = word1.length;
    const len2 = word2.length;
    const minLength = len1 < len2 ? len1 : len2;

    // Iterate through both strings up to the length of the shorter string
    for (let i = 0; i < minLength; i++) {
        merged.push(word1[i]);
        merged.push(word2[i]);
    }

    // Append remaining characters from word1, if any
    for (let i = minLength; i < len1; i++) {
        merged.push(word1[i]);
    }

    // Append remaining characters from word2, if any
    for (let i = minLength; i < len2; i++) {
        merged.push(word2[i]);
    }

    // Join the array into a single string and return it
    let result = '';
    for (let char of merged) {
        result += char;
    }

    return result;
}

// Example usage:
console.log(mergeAlternately(""abc"", ""pqr"")); // Output: ""apbqcr""
console.log(mergeAlternately(""ab"", ""pqrs"")); // Output: ""apbqrs""
console.log(mergeAlternately(""abcd"", ""pq"")); // Output: ""apbqcd"""
Delete N Nodes After M Nodes of a Linked List,"Given the `head` of a linked list and two integers `m` and `n`. Traverse the linked list and remove some nodes in the following way:
Start with the head as the current node.

Keep the first `m` nodes starting with the current node.

Remove the next `n` nodes
Keep repeating steps 2 and 3 until you reach the end of the list.

Return the head of the modified list after removing the mentioned nodes.

Follow up question: How can you solve this problem by modifying the list in-place?

Example 1:
Input: head = [1,2,3,4,5,6,7,8,9,10,11,12,13], m = 2, n = 3
Output: [1,2,6,7,11,12]
Explanation: Keep the first (m = 2) nodes starting from the head of the linked List  (1 ->2) show in black nodes.

Delete the next (n = 3) nodes (3 -> 4 -> 5) show in read nodes.

Continue with the same procedure until reaching the tail of the Linked List.

Head of linked list after removing nodes is returned.


Example 2:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 1, n = 3
Output: [1,5,9]
Explanation: Head of linked list after removing nodes is returned.


Example 3:
Input: head = [1,2,3,4,5,6,7,8,9,10,11], m = 3, n = 1
Output: [1,2,3,5,6,7,9,10,11]

Example 4:
Input: head = [9,3,7,7,9,10,8,2], m = 1, n = 2
Output: [9,7,8]

Constraints:
The given linked list will contain between `1` and `10^4` nodes.

The value of each node in the linked list will be in the range` [1, 10^6]`.

`1 <= m,n <= 1000`",Easy,"class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.next = (next===undefined ? null : next);
    }
}

function deleteNodes(head: ListNode | null, m: number, n: number): ListNode | null {
    let current = head;

    while (current) {
        // Keep the first m nodes
        for (let i = 1; i < m && current; i++) {
            current = current.next;
        }

        if (!current) break;

        // Remove the next n nodes
        let temp = current;
        for (let i = 0; i <= n && temp; i++) {
            temp = temp.next;
        }

        // Connect the m-th node to the node after the n-th node
        current.next = temp;

        // Move to the next segment
        current = temp;
    }

    return head;
}"
Reverse Linked List,"Given the `head` of a singly linked list, reverse the list, and return the reversed list.


Example 1:
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Example 2:
Input: head = [1,2]
Output: [2,1]

Example 3:
Input: head = []
Output: []

Constraints:
The number of nodes in the list is the range `[0, 5000]`.

`-5000 <= Node.val <= 5000`
Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",Easy,"class ListNode {
    val: number;
    next: ListNode | null;
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.next = (next===undefined ? null : next);
    }
}

function reverseListIteratively(head: ListNode | null): ListNode | null {
    let prev: ListNode | null = null;
    let current: ListNode | null = head;
    
    while (current !== null) {
        let nextNode: ListNode | null = current.next; // Store the next node
        current.next = prev; // Reverse the current node's pointer
        prev = current; // Move prev to current
        current = nextNode; // Move to the next node
    }
    
    return prev; // New head of the reversed list
}"
How Many Numbers Are Smaller Than the Current Number,"Given the array `nums`, for each `nums[i]` find out how many numbers in the array are smaller than it. That is, for each `nums[i]` you have to count the number of valid `j's` such that `j != i` and `nums[j] < nums[i]`.

Return the answer in an array.


Example 1:
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.

For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).


Example 2:
Input: nums = [6,5,4,8]
Output: [2,1,0,3]

Example 3:
Input: nums = [7,7,7,7]
Output: [0,0,0,0]

Constraints:
`2 <= nums.length <= 500`
`0 <= nums[i] <= 100`",Easy,"function smallerNumbersThanCurrent(nums: number[]): number[] {
    const result: number[] = [];
    
    for (let i = 0; i < nums.length; i++) {
        let count = 0;
        for (let j = 0; j < nums.length; j++) {
            if (nums[j] < nums[i] && i !== j) {
                count++;
            }
        }
        result.push(count);
    }
    
    return result;
}

// Example usage:
console.log(smallerNumbersThanCurrent([8, 1, 2, 2, 3])); // Output: [4, 0, 1, 1, 3]
console.log(smallerNumbersThanCurrent([6, 5, 4, 8]));     // Output: [2, 1, 0, 3]
console.log(smallerNumbersThanCurrent([7, 7, 7, 7]));     // Output: [0, 0, 0, 0]"
Find All The Lonely Nodes,"In a binary tree, a lonely node is a node that is the only child of its parent node. The root of the tree is not lonely because it does not have a parent node.

Given the `root` of a binary tree, return an array containing the values of all lonely nodes in the tree. Return the list in any order.


Example 1:
Input: root = [1,2,3,null,4]
Output: [4]
Explanation: Light blue node is the only lonely node.

Node 1 is the root and is not lonely.

Nodes 2 and 3 have the same parent and are not lonely.


Example 2:
Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
Output: [6,2]
Explanation: Light blue nodes are lonely nodes.

Please remember that order doesn't matter, [2,6] is also an acceptable answer.


Example 3:
Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
Output: [77,55,33,66,44,22]
Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.

All other nodes are lonely.


Example 4:
Input: root = [197]
Output: []

Example 5:
Input: root = [31,null,78,null,28]
Output: [78,28]

Constraints:
The number of nodes in the `tree` is in the range `[1, 1000].`
Each node's value is between `[1, 10^6]`.",Easy,"// Define the structure for a tree node
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;

    constructor(val: number = 0, left: TreeNode | null = null, right: TreeNode | null = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// Function to find lonely nodes
function getLonelyNodes(root: TreeNode | null): number[] {
    const lonelyNodes: number[] = [];

    // Helper function to traverse the tree
    function traverse(node: TreeNode | null, parentHasOnlyOneChild: boolean): void {
        if (node === null) {
            return;
        }

        // Check if the current node is lonely
        if (parentHasOnlyOneChild) {
            lonelyNodes.push(node.val);
        }

        // Determine if the current node has only one child
        const hasOnlyOneChild = (node.left !== null && node.right === null) || (node.left === null && node.right !== null);

        // Traverse the left and right children
        traverse(node.left, hasOnlyOneChild);
        traverse(node.right, hasOnlyOneChild);
    }

    // Start traversal from the root
    traverse(root, false);

    return lonelyNodes;
}

// Example usage:
const root1 = new TreeNode(1, new TreeNode(2), new TreeNode(3, null, new TreeNode(4)));
console.log(getLonelyNodes(root1)); // Output: [4]

const root2 = new TreeNode(7, new TreeNode(1, new TreeNode(6)), new TreeNode(4, new TreeNode(5), new TreeNode(3, null, new TreeNode(2))));
console.log(getLonelyNodes(root2)); // Output: [6, 2]

const root3 = new TreeNode(11, new TreeNode(99, new TreeNode(77, new TreeNode(55, new TreeNode(33, new TreeNode(66, new TreeNode(44, new TreeNode(22)))))));
console.log(getLonelyNodes(root3)); // Output: [77, 55, 33, 66, 44, 22]

const root4 = new TreeNode(197);
console.log(getLonelyNodes(root4)); // Output: []

const root5 = new TreeNode(31, null, new TreeNode(78, null, new TreeNode(28)));
console.log(getLonelyNodes(root5)); // Output: [78, 28]"
Maximum Ascending Subarray Sum,"Given an array of positive integers `nums`, return the maximum possible sum of an ascending subarray in `nums`.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is ascending if for all `i` where `l <= i < r`, `numsi  < numsi+1`. Note that a subarray of size `1` is ascending.


Example 1:
Input: nums = [10,20,30,5,10,50]
Output: 65
Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65.


Example 2:
Input: nums = [10,20,30,40,50]
Output: 150
Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150.


Example 3:
Input: nums = [12,17,15,13,10,11,12]
Output: 33
Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33.


Example 4:
Input: nums = [100,10,1]
Output: 100

Constraints:
`1 <= nums.length <= 100`
`1 <= nums[i] <= 100`",Easy,"function maxAscendingSum(nums: number[]): number {
    // Initialize variables to keep track of the maximum sum and the current sum
    let maxSum = 0;
    let currentSum = 0;

    // Iterate through the array
    for (let i = 0; i < nums.length; i++) {
        // If it's the first element or the current element is greater than the previous one
        if (i === 0 || nums[i] > nums[i - 1]) {
            // Add the current element to the current sum
            currentSum += nums[i];
        } else {
            // Otherwise, compare the current sum with the max sum and update if needed
            if (currentSum > maxSum) {
                maxSum = currentSum;
            }
            // Reset the current sum to start a new subarray
            currentSum = nums[i];
        }
    }

    // After the loop, ensure we check the last subarray
    if (currentSum > maxSum) {
        maxSum = currentSum;
    }

    // Return the maximum sum found
    return maxSum;
}

// Example usage:
console.log(maxAscendingSum([10, 20, 30, 5, 10, 50])); // Output: 65
console.log(maxAscendingSum([10, 20, 30, 40, 50])); // Output: 150
console.log(maxAscendingSum([12, 17, 15, 13, 10, 11, 12])); // Output: 33
console.log(maxAscendingSum([100, 10, 1])); // Output: 100"
Maximum Subarray Sum After One Operation,"You are given an integer array `nums`. You must perform exactly one operation where you can replace one element `nums[i]` with `nums[i] * nums[i]`. 
Return the maximum possible subarray sum after exactly one operation. The subarray must be non-empty.


Example 1:
Input: nums = [2,-1,-4,-3]
Output: 17
Explanation: You can perform the operation on index 2 (0-indexed) to make nums = [2,-1,16,-3]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.


Example 2:
Input: nums = [1,-1,1,1,-1,-1,1]
Output: 4
Explanation: You can perform the operation on index 1 (0-indexed) to make nums = [1,1,1,1,-1,-1,1]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.


Constraints:
`1 <= nums.length <= 105`
`-104 <= nums[i] <= 104`",Medium,"function maxSubarraySumAfterOperation(nums: number[]): number {
    if (nums.length === 0) return 0;

    let max_ending_here = nums[0];
    let max_ending_here_with_op = nums[0] * nums[0];
    let max_so_far = Math.max(max_ending_here, max_ending_here_with_op);

    for (let i = 1; i < nums.length; i++) {
        const num = nums[i];
        const squared_num = num * num;

        // Update max_ending_here
        max_ending_here = Math.max(num, max_ending_here + num);

        // Update max_ending_here_with_op
        max_ending_here_with_op = Math.max(
            squared_num,
            max_ending_here + squared_num,
            max_ending_here_with_op + num
        );

        // Update max_so_far
        max_so_far = Math.max(max_so_far, max_ending_here, max_ending_here_with_op);
    }

    return max_so_far;
}

// Example usage:
console.log(maxSubarraySumAfterOperation([2, -1, -4, -3])); // Output: 17
console.log(maxSubarraySumAfterOperation([1, -1, 1, 1, -1, -1, 1])); // Output: 4"
Walls and Gates,"You are given an `m x n` grid `rooms` initialized with these three possible values.

`-1` A wall or an obstacle.

`0` A gate.

`INF` Infinity means an empty room. We use the value `231 - 1 = 2147483647` to represent `INF` as you may assume that the distance to a gate is less than `2147483647`.

Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with `INF`.


Example 1:
Input: rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]
Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]

Example 2:
Input: rooms = [[-1]]
Output: [[-1]]

Example 3:
Input: rooms = [[2147483647]]
Output: [[2147483647]]

Example 4:
Input: rooms = [[0]]
Output: [[0]]

Constraints:
`m == rooms.length`
`n == rooms[i].length`
`1 <= m, n <= 250`
`rooms[i][j]` is `-1`, `0`, or `231 - 1`.",Medium,"function wallsAndGates(rooms: number[][]): void {
    const INF = 2147483647;
    const directions = [
        [0, 1],  // right
        [1, 0],  // down
        [0, -1], // left
        [-1, 0]  // up
    ];

    const numRows = rooms.length;
    if (numRows === 0) return;
    const numCols = rooms[0].length;

    // Step 1: Identify all gates and add them to the queue
    const queue: [number, number][] = [];
    for (let row = 0; row < numRows; row++) {
        for (let col = 0; col < numCols; col++) {
            if (rooms[row][col] === 0) {
                queue.push([row, col]);
            }
        }
    }

    // Step 2: Perform BFS from all gates
    while (queue.length > 0) {
        const [currentRow, currentCol] = queue.shift()!;
        const currentDistance = rooms[currentRow][currentCol];

        for (const [dRow, dCol] of directions) {
            const newRow = currentRow + dRow;
            const newCol = currentCol + dCol;

            if (newRow >= 0 && newRow < numRows &&
                newCol >= 0 && newCol < numCols &&
                rooms[newRow][newCol] === INF) {
                
                rooms[newRow][newCol] = currentDistance + 1;
                queue.push([newRow, newCol]);
            }
        }
    }
}

// Example usage:
const rooms1 = [
    [2147483647, -1, 0, 2147483647],
    [2147483647, 2147483647, 2147483647, -1],
    [2147483647, -1, 2147483647, -1],
    [0, -1, 2147483647, 2147483647]
];
wallsAndGates(rooms1);
console.log(rooms1);

const rooms2 = [[-1]];
wallsAndGates(rooms2);
console.log(rooms2);

const rooms3 = [[2147483647]];
wallsAndGates(rooms3);
console.log(rooms3);

const rooms4 = [[0]];
wallsAndGates(rooms4);
console.log(rooms4);"
Longest Common Subsequence,"Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, `""ace""` is a subsequence of `""abcde""`.

A common subsequence of two strings is a subsequence that is common to both strings.


Example 1:
Input: text1 = ""abcde"", text2 = ""ace"" 
Output: 3  
Explanation: The longest common subsequence is ""ace"" and its length is 3.


Example 2:
Input: text1 = ""abc"", text2 = ""abc""
Output: 3
Explanation: The longest common subsequence is ""abc"" and its length is 3.


Example 3:
Input: text1 = ""abc"", text2 = ""def""
Output: 0
Explanation: There is no such common subsequence, so the result is 0.


Constraints:
`1 <= text1.length, text2.length <= 1000`
`text1` and `text2` consist of only lowercase English characters.",Medium,"function longestCommonSubsequence(text1: string, text2: string): number {
    const m = text1.length;
    const n = text2.length;
    
    // Initialize the DP table
    const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    
    // Fill the DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] === text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // The length of the longest common subsequence
    return dp[m][n];
}

// Example usage:
console.log(longestCommonSubsequence(""abcde"", ""ace"")); // Output: 3
console.log(longestCommonSubsequence(""abc"", ""abc""));   // Output: 3
console.log(longestCommonSubsequence(""abc"", ""def""));   // Output: 0"
Satisfiability of Equality Equations,"Given an array equations of strings that represent relationships between variables, each string `equations[i]` has length `4` and takes one of two different forms: `""a==b""` or `""a!=b""`.  Here, `a` and `b` are lowercase letters (not necessarily different) that represent one-letter variable names.

Return `true` if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.


Example 1:
Input: [""a==b"",""b!=a""]
Output: false
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.


Example 2:
Input: [""b==a"",""a==b""]
Output: true
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.


Example 3:
Input: [""a==b"",""b==c"",""a==c""]
Output: true

Example 4:
Input: [""a==b"",""b!=c"",""c==a""]
Output: false

Example 5:
Input: [""c==c"",""b==d"",""x!=z""]
Output: true
Note:
`1 <= equations.length <= 500`
`equations[i].length == 4`
`equations[i][0]` and `equations[i][3]` are lowercase letters
`equations[i][1]` is either `'='` or `'!'`
`equations[i][2]` is `'='`",Medium,"class UnionFind {
    parent: number[];

    constructor(size: number) {
        this.parent = new Array(size);
        for (let i = 0; i < size; i++) {
            this.parent[i] = i;
        }
    }

    find(x: number): number {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]); // Path compression
        }
        return this.parent[x];
    }

    union(x: number, y: number): void {
        const rootX = this.find(x);
        const rootY = this.find(y);
        if (rootX !== rootY) {
            this.parent[rootX] = rootY;
        }
    }
}

function equationsPossible(equations: string[]): boolean {
    const uf = new UnionFind(26);

    // First pass: process all ""=="" equations
    for (const equation of equations) {
        if (equation[1] === '=') {
            const a = equation.charCodeAt(0) - 'a'.charCodeAt(0);
            const b = equation.charCodeAt(3) - 'a'.charCodeAt(0);
            uf.union(a, b);
        }
    }

    // Second pass: process all ""!="" equations
    for (const equation of equations) {
        if (equation[1] === '!') {
            const a = equation.charCodeAt(0) - 'a'.charCodeAt(0);
            const b = equation.charCodeAt(3) - 'a'.charCodeAt(0);
            if (uf.find(a) === uf.find(b)) {
                return false;
            }
        }
    }

    return true;
}

// Example usage:
console.log(equationsPossible([""a==b"", ""b!=a""])); // Output: false
console.log(equationsPossible([""b==a"", ""a==b""])); // Output: true
console.log(equationsPossible([""a==b"", ""b==c"", ""a==c""])); // Output: true
console.log(equationsPossible([""a==b"", ""b!=c"", ""c==a""])); // Output: false
console.log(equationsPossible([""c==c"", ""b==d"", ""x!=z""])); // Output: true"
Check Completeness of a Binary Tree,"Given the `root` of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between `1` and `2h` nodes inclusive at the last level `h`.


Example 1:
Input: root = [1,2,3,4,5,6]
Output: true
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.


Example 2:
Input: root = [1,2,3,4,5,null,7]
Output: false
Explanation: The node with value 7 isn't as far left as possible.


Constraints:
The number of nodes in the tree is in the range `[1, 100]`.

`1 <= Node.val <= 1000`",Medium,"class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;

    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.left = (left===undefined ? null : left);
        this.right = (right===undefined ? null : right);
    }
}

function isCompleteTree(root: TreeNode | null): boolean {
    if (!root) return true;

    const queue: TreeNode[] = [];
    let encounteredMissingChild = false;

    queue.push(root);

    while (queue.length > 0) {
        const currentNode = queue.shift()!;

        if (currentNode.left) {
            if (encounteredMissingChild) {
                return false; // Found a node with a child after a missing child
            }
            queue.push(currentNode.left);
        } else {
            encounteredMissingChild = true;
        }

        if (currentNode.right) {
            if (encounteredMissingChild) {
                return false; // Found a node with a child after a missing child
            }
            queue.push(currentNode.right);
        } else {
            encounteredMissingChild = true;
        }
    }

    return true;
}"
Maximum Number of Non-Overlapping Subarrays With Sum Equals Target,"Given an array `nums` and an integer `target`.

Return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to `target`.


Example 1:
Input: nums = [1,1,1,1,1], target = 2
Output: 2
Explanation: There are 2 non-overlapping subarrays [1,1,1,1,1] with sum equals to target(2).


Example 2:
Input: nums = [-1,3,5,1,4,2,-9], target = 6
Output: 2
Explanation: There are 3 subarrays with sum equal to 6.

([5,1], [4,2], [3,5,1,4,2,-9]) but only the first 2 are non-overlapping.


Example 3:
Input: nums = [-2,6,6,3,5,4,1,2,8], target = 10
Output: 3

Example 4:
Input: nums = [0,0,0], target = 0
Output: 3

Constraints:
`1 <= nums.length <= 10^5`
`-10^4 <= nums[i] <= 10^4`
`0 <= target <= 10^6`",Medium,"function maxNonOverlapping(nums: number[], target: number): number {
    let current_sum = 0;
    const seen_sums = new Set<number>();
    let count = 0;

    for (let i = 0; i < nums.length; i++) {
        current_sum += nums[i];

        // Check if the current sum is equal to the target
        if (current_sum === target) {
            count++;
            current_sum = 0;
            seen_sums.clear();
            continue;
        }

        // Check if there is a prefix sum that makes the current subarray sum to target
        if (seen_sums.has(current_sum - target)) {
            count++;
            current_sum = 0;
            seen_sums.clear();
            continue;
        }

        // Add the current sum to the set of seen sums
        seen_sums.add(current_sum);
    }

    return count;
}

// Example usage:
console.log(maxNonOverlapping([1, 1, 1, 1, 1], 2)); // Output: 2
console.log(maxNonOverlapping([-1, 3, 5, 1, 4, 2, -9], 6)); // Output: 2
console.log(maxNonOverlapping([-2, 6, 6, 3, 5, 4, 1, 2, 8], 10)); // Output: 3
console.log(maxNonOverlapping([0, 0, 0], 0)); // Output: 3"
Find Nearest Right Node in Binary Tree,"Given the `root` of a binary tree and a node `u` in the tree, return the nearest node on the same level that is to the right of `u`, or return `null` if `u` is the rightmost node in its level.


Example 1:
Input: root = [1,2,3,null,4,5,6], u = 4
Output: 5
Explanation: The nearest node on the same level to the right of node 4 is node 5.


Example 2:
Input: root = [3,null,4,2], u = 2
Output: null
Explanation: There are no nodes to the right of 2.


Example 3:
Input: root = [1], u = 1
Output: null

Example 4:
Input: root = [3,4,2,null,null,null,1], u = 4
Output: 2

Constraints:
The number of nodes in the tree is in the range `[1, 105]`.

`1 <= Node.val <= 105`
All values in the tree are distinct.

`u` is a node in the binary tree rooted at `root`.",Medium,"class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val===undefined ? 0 : val);
        this.left = (left===undefined ? null : left);
        this.right = (right===undefined ? null : right);
    }
}

function findNearestRightNode(root: TreeNode | null, u: TreeNode): TreeNode | null {
    if (!root) return null;

    // Initialize a queue for BFS
    const queue: TreeNode[] = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;

        for (let i = 0; i < levelSize; i++) {
            const currentNode = queue.shift()!;

            // Check if the current node is u
            if (currentNode === u) {
                // If u is found and it's not the last node in the level, return the next node
                if (i < levelSize - 1) {
                    return queue.shift()!;
                } else {
                    // If u is the last node in the level, return null
                    return null;
                }
            }

            // Add the children of the current node to the queue
            if (currentNode.left) {
                queue.push(currentNode.left);
            }
            if (currentNode.right) {
                queue.push(currentNode.right);
            }
        }
    }

    // If u is not found in the tree, return null (though the problem guarantees u is in the tree)
    return null;
}"
Put Boxes Into the Warehouse II,"You are given two arrays of positive integers, `boxes` and `warehouse`, representing the heights of some boxes of unit width and the heights of `n` rooms in a warehouse respectively. The warehouse's rooms are labeled from `0` to `n - 1` from left to right where `warehouse[i]` (0-indexed) is the height of the `ith` room.

Boxes are put into the warehouse by the following rules:
Boxes cannot be stacked.

You can rearrange the insertion order of the boxes.

Boxes can be pushed into the warehouse from either side (left or right)
If the height of some room in the warehouse is less than the height of a box, then that box and all other boxes behind it will be stopped before that room.

Return the maximum number of boxes you can put into the warehouse.


Example 1:
Input: boxes = [1,2,2,3,4], warehouse = [3,4,1,2]
Output: 4
Explanation:
We can store the boxes in the following order:
1- Put the yellow box in room 2 from either the left or right side.

2- Put the orange box in room 3 from the right side.

3- Put the green box in room 1 from the left side.

4- Put the red box in room 0 from the left side.

Notice that there are other valid ways to put 4 boxes such as swapping the red and green boxes or the red and orange boxes.


Example 2:
Input: boxes = [3,5,5,2], warehouse = [2,1,3,4,5]
Output: 3
Explanation:
It's not possible to put the two boxes of height 5 in the warehouse since there's only 1 room of height >= 5.

Other valid solutions are to put the green box in room 2 or to put the orange box first in room 2 before putting the green and red boxes.


Example 3:
Input: boxes = [1,2,3], warehouse = [1,2,3,4]
Output: 3

Example 4:
Input: boxes = [4,5,6], warehouse = [3,3,3,3,3]
Output: 0

Constraints:
`n == warehouse.length`
`1 <= boxes.length, warehouse.length <= 105`
`1 <= boxes[i], warehouse[i] <= 109`",Medium,"function maxBoxesInWarehouse(boxes: number[], warehouse: number[]): number {
    const n = warehouse.length;
    
    // Preprocess the warehouse heights
    const leftMinHeights = new Array(n).fill(Number.MAX_SAFE_INTEGER);
    const rightMinHeights = new Array(n).fill(Number.MAX_SAFE_INTEGER);
    
    leftMinHeights[0] = warehouse[0];
    for (let i = 1; i < n; i++) {
        leftMinHeights[i] = Math.min(leftMinHeights[i - 1], warehouse[i]);
    }
    
    rightMinHeights[n - 1] = warehouse[n - 1];
    for (let i = n - 2; i >= 0; i--) {
        rightMinHeights[i] = Math.min(rightMinHeights[i + 1], warehouse[i]);
    }
    
    const effectiveHeights = new Array(n);
    for (let i = 0; i < n; i++) {
        effectiveHeights[i] = Math.max(leftMinHeights[i], rightMinHeights[i]);
    }
    
    // Sort the boxes in ascending order
    boxes.sort((a, b) => a - b);
    
    let boxIndex = 0;
    let left = 0;
    let right = n - 1;
    let insertedBoxes = 0;
    
    while (boxIndex < boxes.length && left <= right) {
        if (boxes[boxIndex] <= effectiveHeights[left]) {
            insertedBoxes++;
            boxIndex++;
            left++;
        } else if (boxes[boxIndex] <= effectiveHeights[right]) {
            insertedBoxes++;
            boxIndex++;
            right--;
        } else {
            // If neither end can accommodate the current box, try the next one
            boxIndex++;
        }
    }
    
    return insertedBoxes;
}

// Example usage:
console.log(maxBoxesInWarehouse([1, 2, 2, 3, 4], [3, 4, 1, 2])); // Output: 4
console.log(maxBoxesInWarehouse([3, 5, 5, 2], [2, 1, 3, 4, 5])); // Output: 3
console.log(maxBoxesInWarehouse([1, 2, 3], [1, 2, 3, 4])); // Output: 3
console.log(maxBoxesInWarehouse([4, 5, 6], [3, 3, 3, 3, 3])); // Output: 0"
Minimum Swaps to Group All 1's Together,"Given a binary array `data`, return the minimum number of swaps required to group all `1`’s present in the array together in any place in the array.


Example 1:
Input: data = [1,0,1,0,1]
Output: 1
Explanation: 
There are 3 ways to group all 1's together:
[1,1,1,0,0] using 1 swap.

[0,1,1,1,0] using 2 swaps.

[0,0,1,1,1] using 1 swap.

The minimum is 1.


Example 2:
Input: data = [0,0,0,1,0]
Output: 0
Explanation: 
Since there is only one 1 in the array, no swaps needed.


Example 3:
Input: data = [1,0,1,0,1,0,0,1,1,0,1]
Output: 3
Explanation: 
One possible solution that uses 3 swaps is [0,0,0,0,0,1,1,1,1,1,1].


Example 4:
Input: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]
Output: 8

Constraints:
`1 <= data.length <= 105`
`data[i]` is `0` or `1`.",Medium,"function minSwaps(data: number[]): number {
    // Step 1: Count the total number of 1s in the array
    let totalOnes = 0;
    for (let i = 0; i < data.length; i++) {
        if (data[i] === 1) {
            totalOnes++;
        }
    }

    // If there are no 1s or only one 1, no swaps are needed
    if (totalOnes <= 1) {
        return 0;
    }

    // Step 2: Initialize variables for the sliding window
    let maxOnesInWindow = 0;
    let currentOnesInWindow = 0;

    // Step 3: Use the sliding window technique
    for (let i = 0; i < data.length; i++) {
        // Add the current element to the window
        if (data[i] === 1) {
            currentOnesInWindow++;
        }

        // Remove the element that is left out of the window
        if (i >= totalOnes && data[i - totalOnes] === 1) {
            currentOnesInWindow--;
        }

        // Update the maximum number of 1s found in any window
        if (currentOnesInWindow > maxOnesInWindow) {
            maxOnesInWindow = currentOnesInWindow;
        }
    }

    // Step 4: Calculate the minimum number of swaps
    return totalOnes - maxOnesInWindow;
}

// Example usage:
console.log(minSwaps([1, 0, 1, 0, 1])); // Output: 1
console.log(minSwaps([0, 0, 0, 1, 0])); // Output: 0
console.log(minSwaps([1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1])); // Output: 3
console.log(minSwaps([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1])); // Output: 8"
Minimum Remove to Make Valid Parentheses,"Given a string s of `'('` , `')'` and lowercase English characters. 
Your task is to remove the minimum number of parentheses ( `'('` or `')'`, in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or
It can be written as `AB` (`A` concatenated with `B`), where `A` and `B` are valid strings, or
It can be written as `(A)`, where `A` is a valid string.


Example 1:
Input: s = ""lee(t(c)o)de)""
Output: ""lee(t(c)o)de""
Explanation: ""lee(t(co)de)"" , ""lee(t(c)ode)"" would also be accepted.


Example 2:
Input: s = ""a)b(c)d""
Output: ""ab(c)d""

Example 3:
Input: s = ""))((""
Output: """"
Explanation: An empty string is also valid.


Example 4:
Input: s = ""(a(b(c)d)""
Output: ""a(b(c)d)""

Constraints:
`1 <= s.length <= 10^5`
`s[i]` is one of  `'('` , `')'` and lowercase English letters`.`",Medium,"function minRemoveToMakeValid(s: string): string {
    let result = Array.from(s);
    let balance = 0;

    // First pass: left to right
    for (let i = 0; i < result.length; i++) {
        if (result[i] === '(') {
            balance++;
        } else if (result[i] === ')') {
            if (balance > 0) {
                balance--;
            } else {
                result[i] = ''; // Mark for removal
            }
        }
    }

    // Second pass: right to left
    balance = 0;
    for (let i = result.length - 1; i >= 0; i--) {
        if (result[i] === ')') {
            balance++;
        } else if (result[i] === '(') {
            if (balance > 0) {
                balance--;
            } else {
                result[i] = ''; // Mark for removal
            }
        }
    }

    // Construct the final result string
    return result.join('');
}

// Example usage:
console.log(minRemoveToMakeValid(""lee(t(c)o)de)"")); // Output: ""lee(t(c)o)de""
console.log(minRemoveToMakeValid(""a)b(c)d""));       // Output: ""ab(c)d""
console.log(minRemoveToMakeValid(""))((""));          // Output: """"
console.log(minRemoveToMakeValid(""(a(b(c)d)""));     // Output: ""a(b(c)d)"""
Trapping Rain Water,"Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.


Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.


Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9

Constraints:
`n == height.length`
`0 <= n <= 3 * 104`
`0 <= height[i] <= 105`",Hard,"function trap(height: number[]): number {
    if (height.length === 0) return 0;

    let left = 0;
    let right = height.length - 1;
    let maxLeft = 0;
    let maxRight = 0;
    let totalWater = 0;

    while (left < right) {
        if (height[left] <= height[right]) {
            if (height[left] >= maxLeft) {
                maxLeft = height[left];
            } else {
                totalWater += maxLeft - height[left];
            }
            left++;
        } else {
            if (height[right] >= maxRight) {
                maxRight = height[right];
            } else {
                totalWater += maxRight - height[right];
            }
            right--;
        }
    }

    return totalWater;
}

// Example usage:
console.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])); // Output: 6
console.log(trap([4, 2, 0, 3, 2, 5])); // Output: 9"
Minimum Cost to Make at Least One Valid Path in a Grid,"Given a m x n `grid`. Each cell of the `grid` has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of `grid[i][j]` can be:
1 which means go to the cell to the right. (i.e go from `grid[i][j]` to `grid[i][j + 1]`)
2 which means go to the cell to the left. (i.e go from `grid[i][j]` to `grid[i][j - 1]`)
3 which means go to the lower cell. (i.e go from `grid[i][j]` to `grid[i + 1][j]`)
4 which means go to the upper cell. (i.e go from `grid[i][j]` to `grid[i - 1][j]`)
Notice that there could be some invalid signs on the cells of the `grid` which points outside the `grid`.

You will initially start at the upper left cell `(0,0)`. A valid path in the grid is a path which starts from the upper left cell `(0,0)` and ends at the bottom-right cell `(m - 1, n - 1)` following the signs on the grid. The valid path doesn't have to be the shortest.

You can modify the sign on a cell with `cost = 1`. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.


Example 1:
Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
Output: 3
Explanation: You will start at point (0, 0).

The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)
The total cost = 3.


Example 2:
Input: grid = [[1,1,3],[3,2,2],[1,1,4]]
Output: 0
Explanation: You can follow the path from (0, 0) to (2, 2).


Example 3:
Input: grid = [[1,2],[4,3]]
Output: 1

Example 4:
Input: grid = [[2,2,2],[2,2,2]]
Output: 3

Example 5:
Input: grid = [[4]]
Output: 0

Constraints:
`m == grid.length`
`n == grid[i].length`
`1 <= m, n <= 100`",Hard,"type Cell = [number, number, number]; // [cost, i, j]

function minCost(grid: number[][]): number {
    const m = grid.length;
    const n = grid[0].length;
    
    // Directions mapping: [right, left, down, up]
    const directions = [
        [0, 1],  // right
        [0, -1], // left
        [1, 0],  // down
        [-1, 0]  // up
    ];
    
    // Priority queue initialization
    const pq: Cell[] = [];
    const dist: number[][] = Array.from({ length: m }, () => Array(n).fill(Infinity));
    
    // Start from the top-left corner
    dist[0][0] = 0;
    pq.push([0, 0, 0]);
    
    while (pq.length > 0) {
        // Extract the cell with the smallest cost
        let [cost, i, j] = pq.shift()!;
        
        // Skip if the current cost is greater than the recorded cost
        if (cost > dist[i][j]) continue;
        
        // Explore neighbors
        for (let k = 0; k < 4; k++) {
            const [di, dj] = directions[k];
            const ni = i + di;
            const nj = j + dj;
            
            // Check if the neighbor is within bounds
            if (ni >= 0 && ni < m && nj >= 0 && nj < n) {
                let newCost = cost;
                
                // If the direction does not match the current sign, add a cost of 1
                if (k + 1 !== grid[i][j]) {
                    newCost += 1;
                }
                
                // Update the cost if it's cheaper
                if (newCost < dist[ni][nj]) {
                    dist[ni][nj] = newCost;
                    pq.push([newCost, ni, nj]);
                }
            }
        }
    }
    
    // Return the minimum cost to reach the bottom-right corner
    return dist[m - 1][n - 1];
}

// Example usage:
console.log(minCost([[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]])); // Output: 3
console.log(minCost([[1,1,3],[3,2,2],[1,1,4]])); // Output: 0
console.log(minCost([[1,2],[4,3]])); // Output: 1
console.log(minCost([[2,2,2],[2,2,2]])); // Output: 3
console.log(minCost([[4]])); // Output: 0"
Pizza With 3n Slices,"There is a pizza with 3n slices of varying size, you and your friends will take slices of pizza as follows:
You will pick any pizza slice.

Your friend Alice will pick next slice in anti clockwise direction of your pick. 
Your friend Bob will pick next slice in clockwise direction of your pick.

Repeat until there are no more slices of pizzas.

Sizes of Pizza slices is represented by circular array `slices` in clockwise direction.

Return the maximum possible sum of slice sizes which you can have.


Example 1:
Input: slices = [1,2,3,4,5,6]
Output: 10
Explanation: Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.


Example 2:
Input: slices = [8,9,8,6,1,1]
Output: 16
Output: Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.

Example 3:
Input: slices = [4,1,2,5,8,3,1,9,7]
Output: 21

Example 4:
Input: slices = [3,1,2]
Output: 3

Constraints:
`1 <= slices.length <= 500`
`slices.length % 3 == 0`
`1 <= slices[i] <= 1000`",Hard,"function maxSizeSlices(slices: number[]): number {
    const n = slices.length;

    // Helper function to calculate the maximum sum of non-adjacent slices
    function maxNonAdjacentSum(start: number, end: number): number {
        const dp = new Array(end - start + 1).fill(0);
        if (start === end) return slices[start];
        
        dp[0] = slices[start];
        dp[1] = Math.max(slices[start], slices[start + 1]);
        
        for (let i = 2; i <= end - start; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + slices[start + i]);
        }
        
        return dp[end - start];
    }

    // Since we cannot pick both the first and last slice due to the circular nature,
    // we need to consider two cases:
    // 1. Exclude the first slice and find the max sum in the rest.
    // 2. Exclude the last slice and find the max sum in the rest.
    // The result will be the maximum of these two cases.
    return Math.max(maxNonAdjacentSum(0, n - 2), maxNonAdjacentSum(1, n - 1));
}

// Example usage:
console.log(maxSizeSlices([1, 2, 3, 4, 5, 6])); // Output: 10
console.log(maxSizeSlices([8, 9, 8, 6, 1, 1])); // Output: 16
console.log(maxSizeSlices([4, 1, 2, 5, 8, 3, 1, 9, 7])); // Output: 21
console.log(maxSizeSlices([3, 1, 2])); // Output: 3"
Number of Ways to Wear Different Hats to Each Other,"There are `n` people and 40 types of hats labeled from 1 to 40.

Given a list of list of integers `hats`, where `hats[i]` is a list of all hats preferred by the i-th` person.

Return the number of ways that the n people wear different hats to each other.

Since the answer may be too large, return it modulo `10^9 + 7`.


Example 1:
Input: hats = [[3,4],[4,5],[5]]
Output: 1
Explanation: There is only one way to choose hats given the conditions. 
First person choose hat 3, Second person choose hat 4 and last one hat 5.


Example 2:
Input: hats = [[3,5,1],[3,5]]
Output: 4
Explanation: There are 4 ways to choose hats
(3,5), (5,3), (1,3) and (1,5)

Example 3:
Input: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
Output: 24
Explanation: Each person can choose hats labeled from 1 to 4.

Number of Permutations of (1,2,3,4) = 24.


Example 4:
Input: hats = [[1,2,3],[2,3,5,6],[1,3,7,9],[1,8,9],[2,5,7]]
Output: 111

Constraints:
`n == hats.length`
`1 <= n <= 10`
`1 <= hats[i].length <= 40`
`1 <= hats[i][j] <= 40`
`hats[i]` contains a list of unique integers.",Hard,"function numberWays(hats: number[][]): number {
    const MOD = 1e9 + 7;
    const n = hats.length;
    
    // Create a mapping from hat to people who prefer that hat
    const hat_to_people: number[][] = Array.from({ length: 41 }, () => []);
    for (let i = 0; i < n; i++) {
        for (const hat of hats[i]) {
            hat_to_people[hat].push(i);
        }
    }
    
    // Initialize the DP table
    const dp: number[] = Array(1 << n).fill(0);
    dp[0] = 1;
    
    // Iterate over each hat
    for (let hat = 1; hat <= 40; hat++) {
        // Iterate over the bitmask of people who can wear this hat
        for (let mask = (1 << n) - 1; mask >= 0; mask--) {
            for (const person of hat_to_people[hat]) {
                if ((mask & (1 << person)) === 0) {
                    // If the person is not already wearing a hat
                    const new_mask = mask | (1 << person);
                    dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD;
                }
            }
        }
    }
    
    // Return the number of ways to assign hats to all people
    return dp[(1 << n) - 1];
}

// Example usage:
console.log(numberWays([[3, 4], [4, 5], [5]])); // Output: 1
console.log(numberWays([[3, 5, 1], [3, 5]])); // Output: 4
console.log(numberWays([[1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]])); // Output: 24
console.log(numberWays([[1, 2, 3], [2, 3, 5, 6], [1, 3, 7, 9], [1, 8, 9], [2, 5, 7]])); // Output: 111"
Find the Kth Smallest Sum of a Matrix With Sorted Rows,"You are given an `m * n` matrix, `mat`, and an integer `k`, which has its rows sorted in non-decreasing order.

You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.


Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5
Output: 7
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,2], [1,4], [3,2], [3,4], [1,6]. Where the 5th sum is 7.  

Example 2:
Input: mat = [[1,3,11],[2,4,6]], k = 9
Output: 17

Example 3:
Input: mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
Output: 9
Explanation: Choosing one element from each row, the first k smallest sum are:
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]. Where the 7th sum is 9.  

Example 4:
Input: mat = [[1,1,10],[2,2,9]], k = 7
Output: 12

Constraints:
`m == mat.length`
`n == mat.length[i]`
`1 <= m, n <= 40`
`1 <= k <= min(200, n ^ m)`
`1 <= mat[i][j] <= 5000`
`mat[i]` is a non decreasing array.",Hard,"class MinHeap {
    private heap: number[];

    constructor() {
        this.heap = [];
    }

    private getParentIndex(index: number): number {
        return Math.floor((index - 1) / 2);
    }

    private getLeftChildIndex(index: number): number {
        return 2 * index + 1;
    }

    private getRightChildIndex(index: number): number {
        return 2 * index + 2;
    }

    private swap(index1: number, index2: number): void {
        const temp = this.heap[index1];
        this.heap[index1] = this.heap[index2];
        this.heap[index2] = temp;
    }

    public insert(value: number): void {
        this.heap.push(value);
        let index = this.heap.length - 1;

        while (index > 0 && this.heap[index] < this.heap[this.getParentIndex(index)]) {
            this.swap(index, this.getParentIndex(index));
            index = this.getParentIndex(index);
        }
    }

    public extractMin(): number | null {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();

        const minValue = this.heap[0];
        this.heap[0] = this.heap.pop()!;
        this.heapify(0);

        return minValue;
    }

    private heapify(index: number): void {
        let smallest = index;
        const leftChildIndex = this.getLeftChildIndex(index);
        const rightChildIndex = this.getRightChildIndex(index);

        if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] < this.heap[smallest]) {
            smallest = leftChildIndex;
        }

        if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] < this.heap[smallest]) {
            smallest = rightChildIndex;
        }

        if (smallest !== index) {
            this.swap(index, smallest);
            this.heapify(smallest);
        }
    }

    public peek(): number | null {
        return this.heap.length > 0 ? this.heap[0] : null;
    }

    public size(): number {
        return this.heap.length;
    }
}

function kthSmallest(mat: number[][], k: number): number {
    const m = mat.length;
    const n = mat[0].length;

    // Initialize the heap with the first row elements
    const minHeap = new MinHeap();
    for (let i = 0; i < n; i++) {
        minHeap.insert(mat[0][i]);
    }

    // Process each row
    for (let row = 1; row < m; row++) {
        const currentHeapSize = minHeap.size();
        for (let i = 0; i < currentHeapSize; i++) {
            const currentSum = minHeap.extractMin()!;
            for (let j = 0; j < n; j++) {
                const newSum = currentSum + mat[row][j];
                minHeap.insert(newSum);
                if (minHeap.size() > k) {
                    minHeap.extractMin();
                }
            }
        }
    }

    return minHeap.peek()!;
}

// Example usage:
console.log(kthSmallest([[1, 3, 11], [2, 4, 6]], 5)); // Output: 7
console.log(kthSmallest([[1, 3, 11], [2, 4, 6]], 9)); // Output: 17
console.log(kthSmallest([[1, 10, 10], [1, 4, 5], [2, 3, 6]], 7)); // Output: 9
console.log(kthSmallest([[1, 1, 10], [2, 2, 9]], 7)); // Output: 12"
Remove Max Number of Edges to Keep Graph Fully Traversable,"Alice and Bob have an undirected graph of `n` nodes and 3 types of edges:
Type 1: Can be traversed by Alice only.

Type 2: Can be traversed by Bob only.

Type 3: Can by traversed by both Alice and Bob.

Given an array `edges` where `edges[i] = [typei, ui, vi]` represents a bidirectional edge of type `typei` between nodes `ui` and `vi`, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return `-1` if it's impossible for the graph to be fully traversed by Alice and Bob.


Example 1:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]]
Output: 2
Explanation: If we remove the 2 edges [1,1,2] and [1,1,3]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.


Example 2:
Input: n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]]
Output: 0
Explanation: Notice that removing any edge will not make the graph fully traversable by Alice and Bob.


Example 3:
Input: n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]]
Output: -1
Explanation: In the current graph, Alice cannot reach node 4 from the other nodes. Likewise, Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.


Constraints:
`1 <= n <= 10^5`
`1 <= edges.length <= min(10^5, 3 * n * (n-1) / 2)`
`edges[i].length == 3`
`1 <= edges[i][0] <= 3`
`1 <= edges[i][1] < edges[i][2] <= n`
All tuples `(typei, ui, vi)` are distinct.",Hard,"class UnionFind {
    parent: number[];
    rank: number[];

    constructor(size: number) {
        this.parent = Array.from({ length: size }, (_, i) => i);
        this.rank = Array(size).fill(0);
    }

    find(x: number): number {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }

    union(x: number, y: number): boolean {
        const rootX = this.find(x);
        const rootY = this.find(y);

        if (rootX === rootY) {
            return false; // Already connected
        }

        if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }

        return true;
    }
}

function maxNumEdgesToRemove(n: number, edges: number[][]): number {
    const aliceUF = new UnionFind(n + 1);
    const bobUF = new UnionFind(n + 1);

    let redundantEdges = 0;

    // Process Type 3 edges first
    for (const [type, u, v] of edges) {
        if (type === 3) {
            if (!aliceUF.union(u, v)) {
                redundantEdges++;
            }
            bobUF.union(u, v); // Bob can also use this edge
        }
    }

    // Process Type 1 edges for Alice
    for (const [type, u, v] of edges) {
        if (type === 1) {
            if (!aliceUF.union(u, v)) {
                redundantEdges++;
            }
        }
    }

    // Process Type 2 edges for Bob
    for (const [type, u, v] of edges) {
        if (type === 2) {
            if (!bobUF.union(u, v)) {
                redundantEdges++;
            }
        }
    }

    // Check if both Alice and Bob can traverse all nodes
    const aliceConnectedComponents = new Set<number>();
    const bobConnectedComponents = new Set<number>();

    for (let i = 1; i <= n; i++) {
        aliceConnectedComponents.add(aliceUF.find(i));
        bobConnectedComponents.add(bobUF.find(i));
    }

    if (aliceConnectedComponents.size !== 1 || bobConnectedComponents.size !== 1) {
        return -1;
    }

    return redundantEdges;
}"
Minimum Operations to Make a Subsequence,"You are given an array `target` that consists of distinct integers and another integer array `arr` that can have duplicates.

In one operation, you can insert any integer at any position in `arr`. For example, if `arr = [1,4,1,2]`, you can add `3` in the middle and make it `[1,4,3,1,2]`. Note that you can insert the integer at the very beginning or end of the array.

Return the minimum number of operations needed to make `target` a subsequence of `arr`.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.


Example 1:
Input: target = [5,1,3], `arr` = [9,4,2,3,4]
Output: 2
Explanation: You can add 5 and 1 in such a way that makes `arr` = [5,9,4,1,2,3,4], then target will be a subsequence of `arr`.


Example 2:
Input: target = [6,4,8,1,3,2], `arr` = [4,7,6,2,3,8,6,1]
Output: 3

Constraints:
`1 <= target.length, arr.length <= 105`
`1 <= target[i], arr[i] <= 109`
`target` contains no duplicates.",Hard,"function minOperations(target: number[], arr: number[]): number {
    // Step 1: Map each element in target to its index
    const targetIndexMap: { [key: number]: number } = {};
    for (let i = 0; i < target.length; i++) {
        targetIndexMap[target[i]] = i;
    }

    // Step 2: Transform arr into a sequence of indices based on targetIndexMap
    const transformedArr: number[] = [];
    for (const num of arr) {
        if (targetIndexMap.hasOwnProperty(num)) {
            transformedArr.push(targetIndexMap[num]);
        }
    }

    // Step 3: Find the Longest Increasing Subsequence (LIS) in transformedArr
    const lis: number[] = [];
    for (const num of transformedArr) {
        let left = 0;
        let right = lis.length;

        // Binary search to find the insertion point
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (lis[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        if (left === lis.length) {
            lis.push(num);
        } else {
            lis[left] = num;
        }
    }

    // Step 4: Calculate the minimum number of insertions
    const lcsLength = lis.length;
    return target.length - lcsLength;
}

// Example usage:
console.log(minOperations([5, 1, 3], [9, 4, 2, 3, 4])); // Output: 2
console.log(minOperations([6, 4, 8, 1, 3, 2], [4, 7, 6, 2, 3, 8, 6, 1])); // Output: 3"
Edit Distance,"Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.

You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character

Example 1:
Input: word1 = ""horse"", word2 = ""ros""
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')

Example 2:
Input: word1 = ""intention"", word2 = ""execution""
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')

Constraints:
`0 <= word1.length, word2.length <= 500`
`word1` and `word2` consist of lowercase English letters.",Hard,"function minDistance(word1: string, word2: string): number {
    const m = word1.length;
    const n = word2.length;

    // Create a 2D array to store the minimum edit distances
    const dp: number[][] = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    // Initialize the base cases
    for (let i = 1; i <= m; i++) {
        dp[i][0] = i; // Deleting all characters from word1
    }
    for (let j = 1; j <= n; j++) {
        dp[0][j] = j; // Inserting all characters into word1
    }

    // Fill the DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1]; // Characters match, no new operation needed
            } else {
                const insertOp = dp[i][j - 1] + 1; // Insert a character
                const deleteOp = dp[i - 1][j] + 1; // Delete a character
                const replaceOp = dp[i - 1][j - 1] + 1; // Replace a character
                dp[i][j] = Math.min(insertOp, deleteOp, replaceOp);
            }
        }
    }

    // The result is in the bottom-right corner of the table
    return dp[m][n];
}

// Example usage:
console.log(minDistance(""horse"", ""ros"")); // Output: 3
console.log(minDistance(""intention"", ""execution"")); // Output: 5"
Maximum Profit in Job Scheduling,"We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.

You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.


Example 1:
Input: startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]
Output: 120
Explanation: The subset chosen is the first and fourth job. 
Time range [1-3]+[3-6] , we get profit of 120 = 50 + 70.


Example 2:
Input: startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]
Output: 150
Explanation: The subset chosen is the first, fourth and fifth job. 
Profit obtained 150 = 20 + 70 + 60.


Example 3:
Input: startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]
Output: 6

Constraints:
`1 <= startTime.length == endTime.length == profit.length <= 5 * 104`
`1 <= startTime[i] < endTime[i] <= 109`
`1 <= profit[i] <= 104`",Hard,"function jobScheduling(startTime: number[], endTime: number[], profit: number[]): number {
    const n = startTime.length;
    
    // Create an array of jobs where each job is represented as [startTime, endTime, profit]
    const jobs: [number, number, number][] = [];
    for (let i = 0; i < n; i++) {
        jobs.push([startTime[i], endTime[i], profit[i]]);
    }
    
    // Sort jobs by end time
    jobs.sort((a, b) => a[1] - b[1]);
    
    // Memoization array to store results of subproblems
    const memo: number[] = new Array(n).fill(-1);
    
    // Recursive function to find the maximum profit starting from job index 'index'
    function maxProfit(index: number): number {
        if (index >= n) {
            return 0;
        }
        
        if (memo[index] !== -1) {
            return memo[index];
        }
        
        // Find the next job that starts after the current job ends
        let nextIndex = n;
        for (let i = index + 1; i < n; i++) {
            if (jobs[i][0] >= jobs[index][1]) {
                nextIndex = i;
                break;
            }
        }
        
        // Include the current job
        const includeCurrent = jobs[index][2] + maxProfit(nextIndex);
        
        // Exclude the current job
        const excludeCurrent = maxProfit(index + 1);
        
        // Store the result in memoization array
        memo[index] = Math.max(includeCurrent, excludeCurrent);
        
        return memo[index];
    }
    
    // Start the recursion from the first job
    return maxProfit(0);
}

// Example usage:
console.log(jobScheduling([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70])); // Output: 120
console.log(jobScheduling([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60])); // Output: 150
console.log(jobScheduling([1, 1, 1], [2, 3, 4], [5, 6, 4])); // Output: 6"
Cherry Pickup II,"Given a `rows x cols` matrix `grid` representing a field of cherries. Each cell in `grid` represents the number of cherries that you can collect.

You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.

Return the maximum number of cherries collection using both robots  by following the rules below:
From a cell (i,j), robots can move to cell (i+1, j-1) , (i+1, j) or (i+1, j+1).

When any robot is passing through a cell, It picks it up all cherries, and the cell becomes an empty cell (0).

When both robots stay on the same cell, only one of them takes the cherries.

Both robots cannot move outside of the grid at any moment.

Both robots should reach the bottom row in the `grid`.


Example 1:
Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]
Output: 24
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.

Cherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.

Total of cherries: 12 + 12 = 24.


Example 2:
Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]
Output: 28
Explanation: Path of robot #1 and #2 are described in color green and blue respectively.

Cherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.

Cherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.

Total of cherries: 17 + 11 = 28.


Example 3:
Input: grid = [[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]]
Output: 22

Example 4:
Input: grid = [[1,1],[1,1]]
Output: 4

Constraints:
`rows == grid.length`
`cols == grid[i].length`
`2 <= rows, cols <= 70`
`0 <= grid[i][j] <= 100 `",Hard,"function cherryPickup(grid: number[][]): number {
    const rows = grid.length;
    const cols = grid[0].length;
    
    // Create a 3D DP array initialized with -1
    const dp: number[][][] = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () =>
            Array(cols).fill(-1)
        )
    );

    // Recursive function to calculate the maximum cherries
    function dfs(i: number, j1: number, j2: number): number {
        // Base case: if we reach the last row, return 0
        if (i === rows) {
            return 0;
        }

        // If the result is already computed, return it
        if (dp[i][j1][j2] !== -1) {
            return dp[i][j1][j2];
        }

        // Calculate the cherries collected by both robots
        let cherries = grid[i][j1];
        if (j1 !== j2) {
            cherries += grid[i][j2];
        }

        // Initialize the maximum cherries collected in the next row
        let maxNext = 0;

        // Iterate over all possible moves for both robots
        for (let dj1 = -1; dj1 <= 1; dj1++) {
            for (let dj2 = -1; dj2 <= 1; dj2++) {
                const newJ1 = j1 + dj1;
                const newJ2 = j2 + dj2;

                // Check if the new positions are within bounds
                if (newJ1 >= 0 && newJ1 < cols && newJ2 >= 0 && newJ2 < cols) {
                    maxNext = Math.max(maxNext, dfs(i + 1, newJ1, newJ2));
                }
            }
        }

        // Store the result in the DP array
        dp[i][j1][j2] = cherries + maxNext;
        return dp[i][j1][j2];
    }

    // Start the recursion from the top row
    return dfs(0, 0, cols - 1);
}

// Example usage:
console.log(cherryPickup([[3,1,1],[2,5,1],[1,5,5],[2,1,1]])); // Output: 24
console.log(cherryPickup([[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]])); // Output: 28
console.log(cherryPickup([[1,0,0,3],[0,0,0,3],[0,0,3,3],[9,0,3,3]])); // Output: 22
console.log(cherryPickup([[1,1],[1,1]])); // Output: 4"
